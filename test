import os
import json
import torch
import scipy.special as sp
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import torch.nn.functional as F
from lime.lime_text import LimeTextExplainer
from typing import Dict, Any, Tuple

class ModelInterpreter:
    def predicts_lime(self, text: str) -> np.ndarray:
        """
        Generates probability predictions using the model for LIME.

        Args:
            text (str): The input text to be tokenized and processed.

        Returns:
            np.ndarray: The predicted probability distribution.
        """
        encoding = self.tokenizer(
            text,
            add_special_tokens=True,
            max_length=128,
            return_token_type_ids=True,
            padding='max_length',
            truncation=True,
            return_attention_mask=True,
            return_tensors='pt'
        )
        
        input_ids = encoding['input_ids'].to(self.device)
        attention_mask = encoding['attention_mask'].to(self.device)
        
        with torch.no_grad():
            logits = self.model(input_ids=input_ids, attention_mask=attention_mask).to(self.device)
            probabilities = F.softmax(logits, dim=-1)
        
        return probabilities.detach().cpu().numpy()
    
    def lime_bert(self, text: str) -> Tuple[Any, Dict[str, Any]]:
        """
        Explains the model's prediction using LIME.

        Args:
            text (str): The input text for explanation.

        Returns:
            Tuple[Any, Dict[str, Any]]: LIME explanation object and explanation data.
        """
        explainer = LimeTextExplainer(class_names=self.labels)
        exp = explainer.explain_instance(text, self.predicts_lime, labels=(0, 1, 2))
        lime_data = {
            "text": text,
            "explanation": {self.labels[label]: exp.as_list(label) for label in exp.available_labels}
        }
        return exp, lime_data
    
    def ig_save_plot(self, fig: plt.Figure, save_dir: str, file_name: str) -> None:
        """
        Saves the given plot to a specified directory.

        Args:
            fig (plt.Figure): The figure to save.
            save_dir (str): The directory where the figure should be saved.
            file_name (str): The name of the saved file.
        """
        os.makedirs(save_dir, exist_ok=True)
        save_path = os.path.join(save_dir, file_name)
        fig.savefig(save_path)
        plt.close(fig)
        print(f"Visualization saved at {save_path}")
    
    def lime_plot(self, explainer: LimeTextExplainer, file_name: str) -> None:
        """
        Saves the LIME explanation plot.

        Args:
            explainer (LimeTextExplainer): The LIME explainer object.
            file_name (str): The name of the saved file.
        """
        save_dir = os.path.join(self.config['results']['path'], "modelInterpreterPlot", "lime")
        os.makedirs(save_dir, exist_ok=True)
        save_path = os.path.join(save_dir, file_name)
        explainer.save_to_file(save_path)
        print("LIME plot is saved")
    
    def save_lime_json(self, lime_data: Dict[str, Any]) -> None:
        """
        Saves the LIME explanation data as a JSON file.

        Args:
            lime_data (Dict[str, Any]): The LIME explanation data to be saved.
        """
        filename = 'lime_text.json'
        save_dir = os.path.join(self.config['results']['path'], "modelInterpreterPlot", "lime")
        os.makedirs(save_dir, exist_ok=True)
        save_json_path = os.path.join(save_dir, filename)
        
        with open(save_json_path, 'w') as f:
            json.dump(lime_data, f, indent=4)
    
    def shap_kurtosis_bar_plot(self, kurtosis_dataframe, class_name: str) -> None:
        """
        Plots and saves a bar plot of SHAP mean for tokens with the lowest SHAP Kurtosis.

        Args:
            kurtosis_dataframe (pd.DataFrame): DataFrame containing SHAP Kurtosis values.
            class_name (str): The class name for the plot title and filename.
        """
        save_dir = os.path.join(self.config['results']['path'], "modelInterpreterPlot", "shap")
        os.makedirs(save_dir, exist_ok=True)
        df = kurtosis_dataframe.nsmallest(30, 'SHAP Kurtosis').sort_values(by="shap_mean", ascending=False)
        
        sns.barplot(x=df['Token'], y=df["shap_mean"], color='blue')
        plt.xlabel("Token")
        plt.ylabel("SHAP Mean")
        plt.title("Bar Plot of Top SHAP Mean for Tokens with 30 Lowest SHAP Kurtosis")
        plt.xticks(rotation=90)
        plt.savefig(os.path.join(save_dir, f"{class_name}_TopMeanLowKurtosisBar.png"))
        print(f"SHAP TopMeanLowKurtosisBar for {class_name} class is saved")
        plt.close()
    
    def shap_kurtosis_df(self, kurtosis_dataframe, label: str) -> None:
        """
        Saves the SHAP Kurtosis DataFrame as a CSV file.

        Args:
            kurtosis_dataframe (pd.DataFrame): DataFrame containing SHAP Kurtosis values.
            label (str): Label for naming the output file.
        """
        save_dir = os.path.join(self.config['results']['path'], "modelInterpreterPlot", "shap")
        file_name = f"{label}_shap_kurtosis.csv"
        os.makedirs(save_dir, exist_ok=True)
        file_path = os.path.join(save_dir, file_name)
        kurtosis_dataframe.to_csv(file_path, index=False)
