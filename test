import re
import json
import unicodedata
from pathlib import Path
from typing import List, Dict

from docx import Document
from docx.oxml.ns import qn
from docx.table import Table
from docx.text.paragraph import Paragraph


# ==================== NORMALIZATION ====================

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


# ==================== DOCX READING ====================

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                row_cells = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            row_cells.append(t)
                if row_cells:
                    lines.append(" | ".join(row_cells))

    return lines


# ==================== REGEX ====================

REQ_ITEMS_RX = re.compile(r"Request\s+Items", re.IGNORECASE)
RFR_RX = re.compile(r"\bRFR\s*\d+", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modell?ing Team['â€™]?s Response", re.IGNORECASE)
BRACKETS_RX = re.compile(r"<\s*([^>]+?)\s*>")
Q_KEY_RX = re.compile(r"Q\d+\s*:", re.IGNORECASE)


# ==================== META EXTRACTION ====================

def extract_meta_from_rfr_header(line: str):
    parts = [norm(x) for x in BRACKETS_RX.findall(line)]

    rfr_q = ""
    imvp = ""
    section = ""

    # RFR Question
    for p in parts:
        if Q_KEY_RX.search(p):
            rfr_q = Q_KEY_RX.sub("", p).strip()
            break

    # IMVP Question
    for p in parts:
        if p.endswith("?") and not Q_KEY_RX.search(p):
            imvp = p
            break

    # Section (short label only)
    for p in parts:
        if (
            not p.endswith("?")
            and not Q_KEY_RX.search(p)
            and not p.lower().startswith("test")
            and len(p.split()) <= 5
        ):
            section = p
            break

    return rfr_q, section, imvp


def extract_test_tags(line: str) -> List[str]:
    """
    <Test S1> -> ['tests1']
    """
    return [
        f"tests{m.group(1).lower()}"
        for m in re.finditer(r"<\s*Test\s*(\w+)\s*>", line, re.IGNORECASE)
    ]


# ==================== CORE PARSER ====================

def parse_lines_after_request_items(lines: List[str]) -> List[Dict]:
    start = 0
    for i, t in enumerate(lines):
        if REQ_ITEMS_RX.search(t):
            start = i + 1
            break

    L = lines[start:]
    rows = []
    i = 0

    while i < len(L):
        line = L[i]

        if RFR_RX.search(line):
            rfr_q, section, imvp = extract_meta_from_rfr_header(line)
            test_tags = extract_test_tags(line)

            followups = {}
            response_text = ""
            current_f_key = None

            in_block = False
            buffer = []
            collecting_response = False

            i += 1

            while i < len(L) and not RFR_RX.search(L[i]):
                cur = L[i].strip()

                if RESP_HDR_RX.search(cur):
                    collecting_response = True
                    i += 1
                    continue

                if cur.startswith("<"):
                    in_block = True
                    buffer = []

                    f_match = re.search(r"<\s*F(\d+)\s*:\s*(.*)", cur, re.IGNORECASE)
                    if f_match:
                        current_f_key = f_match.group(2).strip("â€“- ").strip()

                    i += 1
                    continue

                if cur.startswith(">"):
                    content = norm(" ".join(buffer))
                    in_block = False

                    if collecting_response:
                        if current_f_key:
                            followups[current_f_key] = content
                        else:
                            response_text = content
                        collecting_response = False

                    buffer = []
                    i += 1
                    continue

                if in_block:
                    buffer.append(cur)
                    i += 1
                    continue

                i += 1

            # -------- BUILD RFR PAYLOAD --------
            if followups:
                rfr_payload = followups
            else:
                rfr_payload = response_text

            row = {
                "IMVP Question": imvp,
                "Section": section,
                "rfr": {rfr_q: rfr_payload},
            }

            # ðŸ”¥ THIS IS THE IMPORTANT PART
            for tag in test_tags:
                row[tag] = imvp   # VALUE = IMVP QUESTION

            rows.append(row)
            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"

    rows = parse_lines_after_request_items(read_docx_lines(DOCX_PATH))

    print(json.dumps(rows, indent=2, ensure_ascii=False))


if __name__ == "__main__":
    main()
