import os, json, ast, re
from typing import Any, List, Dict, Optional, Tuple
import pandas as pd
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH


# ---------- small helpers ----------

def _add_heading_run(p, text: str, size: int = 12, bold: bool = True):
    r = p.add_run(text)
    r.font.size = Pt(size)
    r.bold = bold
    return r

def _add_italic_paragraph(doc: Document, text: str):
    p = doc.add_paragraph()
    r = p.add_run(text)
    r.italic = True

def _safe_set_style(paragraph, style_name: str):
    """Try to apply paragraph style by name; fallback silently."""
    try:
        paragraph.style = style_name
    except Exception:
        # style might not exist in the document (custom styles from source);
        # fallback to Normal
        try:
            paragraph.style = 'Normal'
        except Exception:
            pass

def _df_from_list_list(rows: List[List[Any]]) -> pd.DataFrame:
    if not rows:
        return pd.DataFrame()
    header = rows[0]
    data = rows[1:] if len(rows) > 1 else []
    if not all(isinstance(h, str) for h in header):
        header = [f"Col{j+1}" for j in range(len(header))]
    # pad ragged rows
    maxlen = max((len(r) for r in [header] + data), default=0)
    header = header + [f"Col{j+1}" for j in range(len(header), maxlen)]
    data2 = [list(r) + [""]*(maxlen-len(r)) for r in data]
    return pd.DataFrame(data2, columns=header)

def _add_table_from_records(doc: Document, rows: List[Dict[str, Any]]):
    """rows: list of dicts -> render as Word table"""
    if not rows:
        return
    cols = list(rows[0].keys())
    table = doc.add_table(rows=len(rows) + 1, cols=len(cols))
    table.style = "Table Grid"

    # header
    for j, c in enumerate(cols):
        cell = table.cell(0, j)
        cell.text = str(c)
        for run in cell.paragraphs[0].runs:
            run.bold = True

    # body
    for i, row in enumerate(rows):
        for j, c in enumerate(cols):
            val = row.get(c, "")
            table.cell(i + 1, j).text = "" if (pd.isna(val) if isinstance(val, float) else False) else str(val)

def _parse_tables_field(tbl_field: Any) -> List[List[Dict[str, Any]]]:
    """
    Your sample 'table' is a STRING that encodes a LIST of TABLES.
    Each TABLE can be:
      - list[dict, dict, ...]                     -> good
      - list[list-of-dicts] (already "rows")      -> good
    Returns: list_of_tables, where each table is rows(list[dict])
    """
    if not tbl_field or tbl_field == "None":
        return []

    # Step 1: if string, parse JSON / python literal
    if isinstance(tbl_field, str):
        s = tbl_field.strip()
        if not s:
            return []
        parsed = None
        for loader in (json.loads, ast.literal_eval):
            try:
                parsed = loader(s)
                break
            except Exception:
                pass
        if parsed is None:
            return []
        tbl_field = parsed  # now python objects

    # Now tbl_field should be list[...] in your case
    tables_out: List[List[Dict[str, Any]]] = []

    if isinstance(tbl_field, list):
        for sub in tbl_field:
            # Case A: sub is list[dict] -> already rows
            if isinstance(sub, list) and sub and isinstance(sub[0], dict):
                tables_out.append(sub)
            # Case B: sub is dict -> wrap single-row table
            elif isinstance(sub, dict):
                tables_out.append([sub])
            # Case C: sub is list of lists (2D) -> first row headers
            elif isinstance(sub, list) and sub and isinstance(sub[0], (list, tuple)):
                df = _df_from_list_list([list(r) for r in sub])
                tables_out.append(json.loads(df.to_json(orient="records")))
            # else: ignore
    elif isinstance(tbl_field, dict):
        tables_out.append([tbl_field])

    return tables_out

def _split_content_to_paragraphs(content: str) -> List[str]:
    """
    Split markdown-ish content into paragraphs by blank lines,
    but keep bullet lines grouped if possible.
    """
    if not content:
        return []
    # normalize line endings
    text = content.replace("\r\n", "\n").replace("\r", "\n").strip()
    # split on blank lines
    paras = re.split(r"\n\s*\n", text)
    return [p.strip() for p in paras if p.strip()]


# ---------- main builder ----------

def build_template_from_retrieved(
    df: pd.DataFrame,
    model: str,
    impact: str,
    scope: str = "",
    save_dir: str = "base",
    retrieved_col: str = "retrieved_results_output",
    question_col: str = "IMVP Question",
) -> str:
    """
    Build a DOCX from a DF where each row's `retrieved_col` is a JSON list of dicts:
      { "heading": ..., "subheading": ..., "content": ..., "style": "['Normal', 'Heading 2', ...']", "table": "<stringified list of tables>" }

    For each row:
      - "Question i: <IMVP Question>" (bold)
      - "Modelling Team Response" (bold)
      - For each item within retrieved_results_output:
          * print heading/subheading if present
          * split content into paragraphs and apply per-paragraph style from 'style' list when available
          * render any tables as real Word tables
    """
    # sanity checks
    for c in [retrieved_col, question_col]:
        if c not in df.columns:
            raise KeyError(f"Missing column '{c}' in DataFrame.")

    os.makedirs(save_dir, exist_ok=True)
    fname = f"{model}_{impact}{('_' + scope) if scope else ''}.docx"
    out_path = os.path.join(save_dir, fname)

    doc = Document()

    # Title
    p = doc.add_paragraph()
    _add_heading_run(p, "Validation Report (Auto Generated)", size=16, bold=True)
    p.alignment = WD_ALIGN_PARAGRAPH.CENTER
    doc.add_paragraph()

    # Meta
    doc.add_paragraph(f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}")
    doc.add_paragraph()

    # Iterate questions
    for i, row in df.iterrows():
        # --- Question header ---
        q = doc.add_paragraph()
        _add_heading_run(q, f"Question {i+1}: {row[question_col]}", size=12, bold=True)

        # --- Section title for modelling team block ---
        pmt = doc.add_paragraph()
        _add_heading_run(pmt, "Modelling Team Response", size=11, bold=True)

        # Parse retrieved payload
        payload = row[retrieved_col]
        # Convert string -> python list if needed
        if isinstance(payload, str):
            parsed = None
            for loader in (json.loads, ast.literal_eval):
                try:
                    parsed = loader(payload)
                    break
                except Exception:
                    pass
            if parsed is None:
                # If plain text, just write once
                _add_italic_paragraph(doc, payload.strip())
                doc.add_paragraph()
                continue
            payload = parsed

        if not isinstance(payload, list):
            # unknown format, just print as text
            _add_italic_paragraph(doc, str(payload))
            doc.add_paragraph()
            continue

        # For each retrieved item (usually 1..N per row)
        for item in payload:
            if not isinstance(item, dict):
                continue

            heading = str(item.get("heading", "") or "").strip()
            subhead = str(item.get("subheading", "") or "").strip()
            content = str(item.get("content", "") or "").strip()

            # ---- headings/subheadings if present
            if heading:
                ph = doc.add_paragraph()
                # try to use a heading style from the name if available
                # e.g., if heading string itself looks like "7. Testing the Model..." we'll just bold it.
                _add_heading_run(ph, heading, size=11, bold=True)

            if subhead and subhead.lower() not in {"none", "null"}:
                psh = doc.add_paragraph()
                _add_heading_run(psh, subhead, size=11, bold=True)

            # ---- styles array for the content paragraphs
            styles_raw = item.get("style", "")
            styles_list: List[str] = []
            if styles_raw:
                try:
                    # your style comes like "['Heading 2','Normal',...]" -> parse it
                    styles_list = ast.literal_eval(styles_raw) if isinstance(styles_raw, str) else styles_raw
                    if not isinstance(styles_list, list):
                        styles_list = []
                except Exception:
                    styles_list = []

            # ---- write content paragraphs with per-paragraph style where we can
            if content:
                paragraphs = _split_content_to_paragraphs(content)
                for idx, para in enumerate(paragraphs):
                    ppara = doc.add_paragraph()
                    # apply style if provided
                    if idx < len(styles_list) and isinstance(styles_list[idx], str):
                        _safe_set_style(ppara, styles_list[idx])
                    else:
                        # heuristic: bullet lines -> List Paragraph
                        if para.strip().startswith(("-", "*")):
                            _safe_set_style(ppara, "List Paragraph")
                        else:
                            _safe_set_style(ppara, "Normal")
                    ppara.add_run(para)

            # ---- render tables (can be multiple)
            tables = _parse_tables_field(item.get("table"))
            for trows in tables:
                if trows:
                    _add_table_from_records(doc, trows)

        # spacer between questions
        doc.add_paragraph()

    doc.save(out_path)
    return out_path    rows = [ln.split("\t") for ln in block.strip().splitlines()]
    df = _df_from_list_list(rows)
    new_text = text.replace(block, "").strip()
    return df, new_text

def _detect_kv_grid(text: str) -> Tuple[Optional[pd.DataFrame], str]:
    # lines like "Metric: Recall"
    lines = [ln.strip() for ln in text.splitlines()]
    kv = []
    for ln in lines:
        if ":" in ln and not ln.lower().startswith("http"):
            left, right = ln.split(":", 1)
            if left.strip() and right.strip():
                kv.append([left.strip(), right.strip()])
    if len(kv) >= 2:
        df = pd.DataFrame(kv, columns=["Key", "Value"])
        rem = "\n".join(f"{k}: {v}" for k, v in kv)
        new_text = text.replace(rem, "").strip()
        return df, new_text
    return None, text

def _coerce_table_df_to_records(df: Optional[pd.DataFrame]) -> Optional[List[dict]]:
    if df is None or df.empty:
        return None
    return json.loads(df.to_json(orient="records"))

def _extract_text_and_table(val) -> Tuple[str, Optional[List[dict]]]:
    """
    Accept plain string, JSON/python dict/list, or mixed text+table blocks.
    Returns (clean_text_without_table, table_as_list_of_dicts_or_None)
    """
    # dict/list path
    if isinstance(val, dict):
        text = ""
        for k in ("modelling_team_answer", "answer", "text", "response"):
            if k in val and str(val[k]).strip():
                text = str(val[k]).strip()
                break
        tbl = None
        for tk in ("modelling_team_table", "table", "tables", "data"):
            if tk in val and val[tk]:
                tbl = _table_from_any(val[tk])
                break
        return text, tbl

    if isinstance(val, list):
        text, tbl = "", None
        for it in val:
            t, tb = _extract_text_and_table(it)
            if not text and t:
                text = t
            if tbl is None and tb:
                tbl = tb
            if text and tbl:
                break
        return text, tbl

    # string path
    if isinstance(val, str):
        s = val.strip()
        if not s:
            return "", None
        # try parse as JSON/python first
        for loader in (json.loads, ast.literal_eval):
            try:
                parsed = loader(s)
                return _extract_text_and_table(parsed)
            except Exception:
                pass

        # detect embedded tables in raw text
        df = _detect_html_table(s)
        if df is not None:
            s_wo = re.sub(r"<table.*?>.*?</table>", "", s, flags=re.I | re.S).strip()
            return s_wo, _coerce_table_df_to_records(df)
        df, s = _detect_markdown_table(s)
        if df is not None:
            return s, _coerce_table_df_to_records(df)
        df, s2 = _detect_csv_table(s)
        if df is not None:
            return s2, _coerce_table_df_to_records(df)
        df, s3 = _detect_tsv_table(s)
        if df is not None:
            return s3, _coerce_table_df_to_records(df)
        df, s4 = _detect_kv_grid(s)
        if df is not None:
            return s4, _coerce_table_df_to_records(df)
        return s, None

    return "", None


def add_parsed_response_columns(
    df: pd.DataFrame,
    source_col: str,                 # e.g., "modelling_team_response"
    out_text_col: str,               # e.g., "modelling_team_answer"
    out_table_col: str               # e.g., "modelling_team_table"
) -> pd.DataFrame:
    texts, tables = [], []
    for v in df[source_col].tolist():
        t, tbl = _extract_text_and_table(v)
        texts.append(t)
        tables.append(json.dumps(tbl) if tbl else "")
    df[out_text_col] = texts
    df[out_table_col] = tables
    return df


# =========================
# Word builder
# =========================

def _add_heading_run(p, text: str, size: int = 12, bold: bool = True):
    r = p.add_run(text)
    r.font.size = Pt(size)
    r.bold = bold
    return r

def _add_italic_run(p, text: str):
    r = p.add_run(text)
    r.italic = True
    return r

def _add_table_from_records(doc: Document, records_json: str):
    """
    records_json: JSON string of list[dict]; if empty/invalid -> skip
    """
    if not records_json:
        return
    try:
        rows = json.loads(records_json)
    except Exception:
        return
    if not isinstance(rows, list) or not rows:
        return
    if not isinstance(rows[0], dict):
        return

    cols = list(rows[0].keys())
    table = doc.add_table(rows=len(rows) + 1, cols=len(cols))
    table.style = "Table Grid"

    # header
    for j, c in enumerate(cols):
        cell = table.cell(0, j)
        cell.text = str(c)
        for run in cell.paragraphs[0].runs:
            run.bold = True

    # body
    for i, row in enumerate(rows):
        for j, c in enumerate(cols):
            val = row.get(c, "")
            table.cell(i + 1, j).text = "" if (pd.isna(val) if isinstance(val, float) else False) else str(val)

def build_template_with_df(
    df: pd.DataFrame,
    model: str,
    impact: str,
    scope: str = "",
    save_dir: str = "base",
    question_col: str = "IMVP Question",
    modelling_text_col: str = "modelling_team_answer",
    mrmg_text_col: str = "mrmg_answer",
    modelling_table_col: Optional[str] = "modelling_team_table",
    mrmg_table_col: Optional[str] = "mrmg_table"
) -> str:
    """
    For each row:
      - Question i: <IMVP Question> (bold)
      - Modelling Team Response (bold): text + table (if any)
      - MRMG Assessment (bold): text + table (if any)
    """
    # sanity check for required columns
    for col in [question_col]:
        if col not in df.columns:
            raise KeyError(f"Missing required column in df: '{col}'")

    os.makedirs(save_dir, exist_ok=True)
    fname = f"{model}_{impact}{('_' + scope) if scope else ''}.docx"
    out_path = os.path.join(save_dir, fname)

    doc = Document()

    # Title
    p = doc.add_paragraph()
    _add_heading_run(p, "Validation Report (Auto Generated)", size=16, bold=True)
    p.alignment = WD_ALIGN_PARAGRAPH.CENTER
    doc.add_paragraph()

    # Meta
    doc.add_paragraph(f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}")
    doc.add_paragraph()

    # Per-question blocks
    for i, row in df.iterrows():
        # QUESTION
        q = doc.add_paragraph()
        _add_heading_run(q, f"Question {i+1}: {row[question_col]}", size=12, bold=True)

        # MODELLING TEAM
        p1 = doc.add_paragraph()
        _add_heading_run(p1, "Modelling Team Response", size=11, bold=True)

        mt = str(row.get(modelling_text_col, "") or "").strip()
        if mt:
            pt = doc.add_paragraph()
            _add_italic_run(pt, mt)
        if modelling_table_col and modelling_table_col in df.columns:
            _add_table_from_records(doc, str(row.get(modelling_table_col, "") or ""))

        # MRMG
        p2 = doc.add_paragraph()
        _add_heading_run(p2, "MRMG Assessment", size=11, bold=True)

        ma = str(row.get(mrmg_text_col, "") or "").strip()
        if ma:
            pt2 = doc.add_paragraph()
            _add_italic_run(pt2, ma)
        if mrmg_table_col and mrmg_table_col in df.columns:
            _add_table_from_records(doc, str(row.get(mrmg_table_col, "") or ""))

        doc.add_paragraph()  # spacer

    doc.save(out_path)
    return out_path


# =========================
# Example usage (edit paths)
# =========================
if __name__ == "__main__":
    # 1) Load your CSV â†’ must include at least 'IMVP Question' and 'modelling_team_response'
    #    (If your file is Excel, use pd.read_excel)
    df = pd.read_csv("mapping/Business_C.csv")

    # 2) Create the columns the builder needs from your single modelling column
    df = add_parsed_response_columns(
        df,
        source_col="modelling_team_response",   # <- your raw column
        out_text_col="modelling_team_answer",
        out_table_col="modelling_team_table"
    )

    # (Optional) If you ALSO have a single raw MRMG column, parse it too
    if "mrmg_response" in df.columns:
        df = add_parsed_response_columns(
            df,
            source_col="mrmg_response",
            out_text_col="mrmg_answer",
            out_table_col="mrmg_table"
        )
    else:
        # ensure columns exist
        if "mrmg_answer" not in df.columns:
            df["mrmg_answer"] = ""
        if "mrmg_table" not in df.columns:
            df["mrmg_table"] = ""

    # 3) Build the DOCX (saved under base/<Model>_<Impact>.docx)
    out_path = build_template_with_df(
        df,
        model="Business",
        impact="C",
        scope="",                # or "V"
        save_dir="base",
        question_col="IMVP Question",
        modelling_text_col="modelling_team_answer",
        mrmg_text_col="mrmg_answer",
        modelling_table_col="modelling_team_table",
        mrmg_table_col="mrmg_table"
    )
    print("Saved:", out_path)
