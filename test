
import re
import json
import unicodedata
from pathlib import Path
from typing import List, Dict

from docx import Document
from docx.oxml.ns import qn
from docx.table import Table
from docx.text.paragraph import Paragraph


# ==================== NORMALIZATION ====================

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


# ==================== DOCX READING ====================

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines: List[str] = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                row_cells = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            row_cells.append(t)
                if row_cells:
                    lines.append(" | ".join(row_cells))

    return lines


# ==================== REGEX ====================

REQ_ITEMS_RX = re.compile(r"Request\s+Items", re.IGNORECASE)
RFR_RX = re.compile(r"\bRFR\s*\d+", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modell?ing Team['’]?s Response", re.IGNORECASE)
BRACKETS_RX = re.compile(r"<\s*([^>]+?)\s*>")
Q_KEY_RX = re.compile(r"Q\d+\s*:", re.IGNORECASE)


# ==================== META EXTRACTION ====================

def extract_meta_from_rfr_header(line: str):
    parts = [norm(x) for x in BRACKETS_RX.findall(line)]

    rfr_q = ""
    imvp = ""
    section = ""

    # RFR question (Q1/Q2/...)
    for p in parts:
        if Q_KEY_RX.search(p):
            rfr_q = Q_KEY_RX.sub("", p).strip()
            break

    # IMVP question (ends with ?)
    for p in parts:
        if p.endswith("?") and not Q_KEY_RX.search(p):
            imvp = p
            break

    # Section (short label only)
    for p in parts:
        if (
            not p.endswith("?")
            and not Q_KEY_RX.search(p)
            and not p.lower().startswith("test")
            and len(p.split()) <= 5
        ):
            section = p
            break

    return rfr_q, section, imvp


def extract_test_tags(line: str) -> List[str]:
    """
    <Test S1> -> ['tests1']
    <Test S2> -> ['tests2']
    """
    tags = []
    for m in re.finditer(r"<\s*Test\s*S(\d+)\s*>", line, re.IGNORECASE):
        tags.append(f"tests{m.group(1)}")
    return tags


# ==================== CORE PARSER ====================

def parse_lines_after_request_items(lines: List[str]) -> List[Dict]:
    start = 0
    for i, t in enumerate(lines):
        if REQ_ITEMS_RX.search(t):
            start = i + 1
            break

    L = lines[start:]
    rows: List[Dict] = []
    i = 0

    while i < len(L):
        line = L[i]

        if RFR_RX.search(line):
            rfr_q, section, imvp = extract_meta_from_rfr_header(line)
            test_tags = extract_test_tags(line)

            followups: Dict[str, str] = {}
            response_text = ""
            current_f_key = None

            in_block = False
            buffer: List[str] = []
            collecting_response = False

            i += 1

            while i < len(L) and not RFR_RX.search(L[i]):
                cur = L[i].strip()

                # ---- Response header ----
                if RESP_HDR_RX.search(cur):
                    collecting_response = True
                    i += 1
                    continue

                # ---- Open < ----
                if cur.startswith("<"):
                    in_block = True
                    buffer = []

                    # Detect F1/F2/... ONLY here
                    f_match = re.search(r"<\s*F\d+\s*:\s*(.*)", cur, re.IGNORECASE)
                    if f_match:
                        current_f_key = f_match.group(1).strip("–- ").strip()

                    i += 1
                    continue

                # ---- Close > ----
                if cur.startswith(">"):
                    content = norm(" ".join(buffer))
                    in_block = False

                    if collecting_response:
                        if current_f_key:
                            followups[current_f_key] = content
                        else:
                            response_text = content
                        collecting_response = False

                    buffer = []
                    i += 1
                    continue

                # ---- Collect block text ----
                if in_block:
                    buffer.append(cur)
                    i += 1
                    continue

                i += 1

            # ---- Build RFR payload ----
            if followups:
                rfr_payload = followups
            else:
                rfr_payload = response_text

            row = {
                "IMVP Question": imvp,
                "Section": section,
                "rfr": {
                    rfr_q: rfr_payload
                }
            }

            # ✅ tests1 value = IMVP Question
            for tag in test_tags:
                row[tag] = imvp

            rows.append(row)
            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"

    if not Path(DOCX_PATH).exists():
        print("❌ DOCX file not found")
        return

    rows = parse_lines_after_request_items(read_docx_lines(DOCX_PATH))

    print(json.dumps(rows, indent=2, ensure_ascii=False))


if __name__ == "__main__":
    main()
