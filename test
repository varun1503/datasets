from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import os
import json
import ast
from typing import Optional, Any, Iterable
import pandas as pd

def add_title_to_top(doc: Document, model, impact, scope, title_text="Validation Report (Template)"):
    # Insert a paragraph at the very beginning
    if doc.paragraphs:
        p = doc.paragraphs[0].insert_paragraph_before()
    else:
        p = doc.add_paragraph()
    r = p.add_run(title_text)
    r.bold = True
    r.font.size = Pt(16)
    p.alignment = WD_ALIGN_PARAGRAPH.CENTER

    # Subtitle line beneath the title
    sub = doc.add_paragraph()
    sub_run = sub.add_run(f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}")
    sub_run.font.size = Pt(11)

    # Spacer
    doc.add_paragraph()
    return doc

# ---------- helpers ----------
def _bold_run(p, text, size=11):
    r = p.add_run(text)
    r.bold = True
    r.font.size = Pt(size)
    return r

def _normal_run(p, text, size=11):
    r = p.add_run(text)
    r.font.size = Pt(size)
    return r

def safe_json_loads(cell: Any):
    """Pass-through for dict/list; try json/literal for strings."""
    if isinstance(cell, (dict, list)) or cell is None:
        return cell
    if not isinstance(cell, str):
        return cell
    try:
        return json.loads(cell)
    except Exception:
        pass
    try:
        return ast.literal_eval(cell)
    except Exception:
        return cell

def _add_heading(doc: Document, text: str, size=12):
    p = doc.add_paragraph()
    _bold_run(p, text, size=size)

def _add_rfr_block(doc: Document, rfr_obj: Any):
    """
    Render an RFR section from a dict like {"Q1": "answer ...", "Q2": "..."}.
    Also tolerates JSON-ish strings by parsing first.
    """
    rfr_obj = safe_json_loads(rfr_obj)
    if not rfr_obj:
        _normal_run(doc.add_paragraph(), "(No RFR provided)")
        return

    if isinstance(rfr_obj, dict):
        for k, v in rfr_obj.items():
            # Question key (bold)
            p_q = doc.add_paragraph()
            _bold_run(p_q, f"{str(k).strip()}: ", size=11)

            # Response/value
            p_a = doc.add_paragraph()
            _bold_run(p_a, "Response: ", size=11)
            _normal_run(p_a, str(v).strip())
    else:
        # Fallback dump
        _normal_run(doc.add_paragraph(), str(rfr_obj).strip())

def _as_finding_lines(x: Any):
    """
    Normalize findings to list[str]. Accepts list/ dict / string / JSON-ish.
    """
    x = safe_json_loads(x)
    if x is None:
        return []
    if isinstance(x, list):
        return [str(it).strip() for it in x if str(it).strip()]
    if isinstance(x, dict):
        return [f"{k}: {v}" for k, v in x.items() if str(v).strip()]
    if isinstance(x, str):
        s = x.strip()
        return [s] if s else []
    return [str(x).strip()]

def _add_findings_table(doc: Document, findings_df: Optional[pd.DataFrame]):
    """
    Insert a 'Findings' heading and a table with the specified columns, if data exists.
    Expected columns (case-insensitive tolerant):
      - IMVP question
      - Finding Impact Category
      - Finding Details
      - Finding Status
    """
    if findings_df is None or len(findings_df) == 0:
        return

    # Normalize column names for tolerant matching
    colmap = {c.lower().strip(): c for c in findings_df.columns}

    def pick(*aliases):
        for a in aliases:
            if a.lower() in colmap:
                return colmap[a.lower()]
        return None

    col_imvp    = pick("IMVP question", "IMVP Question", "imvp_question", "imvp q", "imvp")
    col_impact  = pick("Finding Impact Category", "Impact Category", "finding impact category", "impact")
    col_detail  = pick("Finding Details", "Finding Detail", "details", "finding details")
    col_status  = pick("Finding Status", "Status", "finding status")

    cols = [col_imvp, col_impact, col_detail, col_status]
    if not all(cols):
        # If any required column is missing, skip gracefully
        _add_heading(doc, "Findings", size=12)
        _normal_run(doc.add_paragraph(), "(Findings table skipped: required columns not found)")
        doc.add_paragraph()
        return

    # Heading
    _add_heading(doc, "Findings", size=12)

    # Create table
    table = doc.add_table(rows=1, cols=4)
    hdr_cells = table.rows[0].cells
    hdr_cells[0].text = "IMVP Question"
    hdr_cells[1].text = "Finding Impact Category"
    hdr_cells[2].text = "Finding Details"
    hdr_cells[3].text = "Finding Status"

    # Rows
    for _, r in findings_df.iterrows():
        row_cells = table.add_row().cells
        row_cells[0].text = str(r.get(col_imvp, "") or "").strip()
        row_cells[1].text = str(r.get(col_impact, "") or "").strip()
        row_cells[2].text = str(r.get(col_detail, "") or "").strip()
        row_cells[3].text = str(r.get(col_status, "") or "").strip()

    # Spacer after table
    doc.add_paragraph()


# ---------- main ----------
def build_simple_template(
    df: pd.DataFrame,
    model: str,
    impact: str,
    prepend_docx_path: str,
    scope: str = "",
    save_dir: str = "base",
    *,
    findings_df: Optional[pd.DataFrame] = None,   # <<< NEW: pass your Excel dataframe here
    question_col: str = "text",
    sections_col: str = "sections",
    mrmg_col: Optional[str] = "mrmg_answer",
    heading_col: Optional[str] = None,            # if you have one
    rfr_col: str = "RFR",                         # your dict column (already set)
    finding_col: Optional[str] = "Findings",
    page_break: bool = True,
    blank_lines_under_mtr: int = 2
) -> str:
    # sanity
    for col in [question_col, sections_col]:
        if col not in df.columns:
            raise KeyError(f"Missing required column: {col}")

    os.makedirs(save_dir, exist_ok=True)
    out_path = os.path.join(save_dir, f"{model}_{impact}{('_' + scope) if scope else ''}.docx")

    doc = Document(prepend_docx_path) if prepend_docx_path else Document()

    # Title + (optional page break)
    add_title_to_top(doc, model=model, impact=impact, scope=scope)
    if prepend_docx_path and page_break:
        doc.add_page_break()

    # >>> Insert FINDINGS section + table right after prepend/title
    _add_findings_table(doc, findings_df)

    # Rows for Q/A, Sections, RFR, etc.
    for i, row in df.iterrows():
        # Question
        pq = doc.add_paragraph()
        _bold_run(pq, f"Question {i+1}: ", size=12)
        _normal_run(pq, str(row[question_col]).strip())
        doc.add_paragraph()

        # Section
        ps = doc.add_paragraph()
        _bold_run(ps, "Section: ")
        _normal_run(ps, str(row[sections_col]).strip())
        doc.add_paragraph()

        # Optional Heading
        if heading_col and heading_col in df.columns:
            ph = doc.add_paragraph()
            _bold_run(ph, "Heading: ")
            _normal_run(ph, str(row.get(heading_col, "")).strip())
            doc.add_paragraph()

        # MRMG Assessment (if present)
        if mrmg_col and mrmg_col in df.columns:
            pm = doc.add_paragraph()
            _bold_run(pm, "MRMG Assessment: ")
            _normal_run(pm, str(row.get(mrmg_col, "")).strip())
            doc.add_paragraph()

        # RFR
        if rfr_col in df.columns:
            _add_heading(doc, "RFR", size=12)
            _add_rfr_block(doc, row.get(rfr_col))

        # Findings (per-question free text list, if you still want it)
        if finding_col and finding_col in df.columns:
            _add_heading(doc, "Findings", size=12)
            lines = _as_finding_lines(row.get(finding_col))
            if lines:
                for line in lines:
                    p = doc.add_paragraph(style=None)
                    try:
                        p.style = doc.styles['List Bullet']  # bullet style if available
                    except Exception:
                        pass
                    _normal_run(p, line)
            else:
                _normal_run(doc.add_paragraph(), "(No findings provided)")

        # Modelling Team Response (space)
        pmt = doc.add_paragraph()
        _bold_run(pmt, "Modelling Team Response", size=11)
        for _ in range(max(0, blank_lines_under_mtr)):
            doc.add_paragraph()
        # spacer
        doc.add_paragraph()

    doc.save(out_path)
    return out_path
