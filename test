"""
Word Document Annotation Filler
================================
Automatically fills placeholder sections in Word documents with annotations from a DataFrame.

Features:
- Multi-line section matching
- Markdown-style formatting (**bold**, - bullets)
- Smart section name normalization
- Comprehensive error handling and logging

Author: Claude
Date: 2026-01-28
"""

import pandas as pd
from docx import Document
from docx.shared import Pt, Inches
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
import re
from typing import Dict, List, Tuple, Optional
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s: %(message)s'
)
logger = logging.getLogger(__name__)


class DocumentAnnotationFiller:
    """Fill Word document placeholders with formatted annotations."""
    
    PLACEHOLDER_PATTERNS = ['{}', '{Placeholder}', '{placeholder}', '{ }']
    LOOKAHEAD_PARAGRAPHS = 8  # How many paragraphs to search for placeholder
    
    def __init__(self, df: pd.DataFrame):
        """
        Initialize with DataFrame containing annotations.
        
        Args:
            df: DataFrame with columns 'annotation section' and 'summary'
        """
        self.df = df
        self.section_to_annotation = self._prepare_annotations()
        
    def _prepare_annotations(self) -> Dict[str, str]:
        """Prepare and validate annotation mappings."""
        # Filter out rows without annotations
        df_clean = self.df[self.df['summary'].notna()].copy()
        
        if df_clean.empty:
            logger.warning("No valid annotations found in DataFrame!")
            return {}
        
        # Create mapping
        mapping = dict(zip(df_clean['annotation section'], df_clean['summary']))
        
        # Check for duplicates
        duplicates = df_clean['annotation section'].value_counts()
        duplicates = duplicates[duplicates > 1]
        if not duplicates.empty:
            logger.warning(f"Duplicate section names found: {duplicates.index.tolist()}")
        
        logger.info(f"Loaded {len(mapping)} annotation mappings")
        return mapping
    
    @staticmethod
    def normalize_section_name(text: str) -> str:
        """
        Normalize section name for matching.
        
        - Removes numbering (1., 1.1, etc.)
        - Strips whitespace
        - Handles newline variations
        """
        # Remove numbering prefix (e.g., "1.", "1.1.", "2.3.4.")
        text = re.sub(r'^\d+(\.\d+)*\.?\s*', '', text)
        # Strip whitespace
        text = text.strip()
        return text
    
    def find_section_match(self, heading_text: str) -> Optional[str]:
        """
        Find best matching section key for a heading.
        
        Args:
            heading_text: Text from document heading
            
        Returns:
            Matching section key or None
        """
        heading_normalized = self.normalize_section_name(heading_text)
        
        # Try exact match
        for key in self.section_to_annotation.keys():
            key_normalized = self.normalize_section_name(key)
            if heading_normalized == key_normalized:
                return key
        
        # Try with newline conversion (\\n to actual newline)
        for key in self.section_to_annotation.keys():
            key_with_newlines = key.replace('\\n', '\n')
            key_normalized = self.normalize_section_name(key_with_newlines)
            if heading_normalized == key_normalized:
                return key
        
        # Try matching first line only (for multi-line sections)
        heading_first_line = heading_normalized.split('\n')[0] if '\n' in heading_normalized else heading_normalized
        
        for key in self.section_to_annotation.keys():
            key_with_newlines = key.replace('\\n', '\n')
            key_normalized = self.normalize_section_name(key_with_newlines)
            key_first_line = key_normalized.split('\n')[0] if '\n' in key_normalized else key_normalized
            
            # Match if first lines are same and heading has substance
            if key_first_line == heading_first_line and len(heading_first_line) > 5:
                return key
        
        return None
    
    @staticmethod
    def add_formatted_text(paragraph, text: str):
        """
        Add formatted text to paragraph, handling markdown-style formatting.
        
        Supports:
        - **bold text**
        - - bullet points
        - Line breaks
        - Yellow highlighting on all inserted text
        
        Args:
            paragraph: docx Paragraph object
            text: Text with markdown formatting
        """
        # Clear existing content
        paragraph.clear()
        
        # Split text into lines
        lines = text.split('\n')
        
        for line_idx, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            
            # Handle bullet points
            is_bullet = line.startswith('- ')
            if is_bullet:
                line = '• ' + line[2:]
                # Set bullet indentation
                pPr = paragraph._element.get_or_add_pPr()
                ind = OxmlElement('w:ind')
                ind.set(qn('w:left'), '720')   # Left indent (0.5 inch)
                ind.set(qn('w:hanging'), '360')  # Hanging indent (0.25 inch)
                pPr.append(ind)
            
            # Handle bold text with ** markers
            if '**' in line:
                parts = line.split('**')
                for idx, part in enumerate(parts):
                    if part:
                        run = paragraph.add_run(part)
                        run.font.size = Pt(11)
                        run.font.name = 'Times New Roman'
                        run.font.highlight_color = 7  # Yellow highlight (WD_COLOR_INDEX.YELLOW = 7)
                        # Odd indices (1, 3, 5...) are bold content
                        if idx % 2 == 1:
                            run.bold = True
            else:
                # Plain text
                run = paragraph.add_run(line)
                run.font.size = Pt(11)
                run.font.name = 'Times New Roman'
                run.font.highlight_color = 7  # Yellow highlight
            
            # Add line break between lines (but not after last line)
            if line_idx < len(lines) - 1:
                paragraph.add_run('\n')
        
        # Set paragraph spacing
        paragraph.paragraph_format.space_after = Pt(10)
        paragraph.paragraph_format.space_before = Pt(0)
        paragraph.paragraph_format.line_spacing = 1.15
    
    def fill_document(self, doc_path: str, output_path: str) -> Dict[str, int]:
        """
        Fill Word document placeholders with annotations.
        
        Args:
            doc_path: Path to input Word document
            output_path: Path to save filled document
            
        Returns:
            Dictionary with statistics (matched, filled, no_placeholder)
        """
        # Load document
        try:
            doc = Document(doc_path)
        except Exception as e:
            logger.error(f"Failed to load document: {e}")
            raise
        
        # Track statistics
        stats = {
            'matched': 0,
            'filled': 0,
            'no_placeholder': 0,
            'total_sections': len(self.section_to_annotation)
        }
        
        # Process paragraphs
        paragraphs = doc.paragraphs
        
        logger.info(f"Processing {len(paragraphs)} paragraphs...")
        
        for i, para in enumerate(paragraphs):
            heading_text = para.text.strip()
            
            # Skip empty paragraphs
            if not heading_text:
                continue
            
            # Try to find a matching section
            matched_key = self.find_section_match(heading_text)
            
            if matched_key:
                stats['matched'] += 1
                annotation_text = self.section_to_annotation[matched_key]
                
                # Truncate long headings for display
                display_heading = heading_text[:60] + '...' if len(heading_text) > 60 else heading_text
                logger.info(f"✓ Matched: '{display_heading}'")
                
                # Look ahead for placeholder
                placeholder_found = False
                for j in range(i + 1, min(i + self.LOOKAHEAD_PARAGRAPHS, len(paragraphs))):
                    next_para = paragraphs[j]
                    next_text = next_para.text.strip()
                    
                    # Check for placeholder patterns
                    if next_text in self.PLACEHOLDER_PATTERNS:
                        logger.info(f"  → Filling placeholder at paragraph {j}")
                        
                        # Fill with formatted content
                        self.add_formatted_text(next_para, annotation_text)
                        
                        placeholder_found = True
                        stats['filled'] += 1
                        break
                    
                    # Stop looking if we hit another heading (style-based check)
                    if next_para.style.name.startswith('Heading'):
                        break
                
                if not placeholder_found:
                    logger.warning(f"  ⚠ No placeholder found for: '{display_heading}'")
                    stats['no_placeholder'] += 1
        
        # Save document
        try:
            doc.save(output_path)
            logger.info(f"✓ Document saved to: {output_path}")
        except Exception as e:
            logger.error(f"Failed to save document: {e}")
            raise
        
        return stats
    
    def print_summary(self, stats: Dict[str, int]):
        """Print processing summary."""
        print("\n" + "="*60)
        print("SUMMARY")
        print("="*60)
        print(f"Total sections in CSV: {stats['total_sections']}")
        print(f"Sections matched: {stats['matched']}")
        print(f"Placeholders filled: {stats['filled']}")
        print(f"Missing placeholders: {stats['no_placeholder']}")
        
        if stats['matched'] > 0:
            success_rate = (stats['filled'] / stats['matched']) * 100
            print(f"Success rate: {success_rate:.1f}%")
        
        print("="*60)


# -----------------------------
# Convenience Functions
# -----------------------------

def fill_document_with_annotations(df: pd.DataFrame, 
                                  doc_path: str, 
                                  output_path: str) -> Dict[str, int]:
    """
    Convenience function to fill document in one call.
    
    Args:
        df: DataFrame with 'annotation section' and 'summary' columns
        doc_path: Path to input Word document
        output_path: Path to save filled document
        
    Returns:
        Dictionary with processing statistics
    """
    filler = DocumentAnnotationFiller(df)
    stats = filler.fill_document(doc_path, output_path)
    filler.print_summary(stats)
    return stats


# -----------------------------
# Main Execution
# -----------------------------

if __name__ == "__main__":
    """
    Example usage:
    
    1. Prepare your DataFrame with columns:
       - 'annotation section': Section names (can include \n for multi-line)
       - 'summary': Annotation text to insert
    
    2. Call fill_document_with_annotations()
    """
    
    # Example: Load from CSV
    # result_df = pd.read_csv('annotations.csv')
    
    # Example: Create sample DataFrame
    sample_data = {
        'annotation section': [
            'Executive Summary',
            'Model Purpose',
            'Model Framework and Approach\\nModel Algorithm',
            'Data Sources',
            'Key Assumptions'
        ],
        'summary': [
            'This model provides **comprehensive analysis** of financial metrics and risk assessment.',
            'The purpose of this model is to:\n- Automate financial reporting\n- Provide real-time insights\n- Enable accurate forecasting',
            'The model uses **machine learning** techniques including:\n- Random Forest classifier\n- Cross-validation approach\n- Feature engineering',
            'Data sources include:\n- Internal databases\n- Market data feeds\n- Third-party vendor data',
            'Key assumptions include:\n- **Historical patterns** will continue\n- Data quality will be maintained\n- Market conditions remain stable'
        ]
    }
    result_df = pd.DataFrame(sample_data)
    
    # Fill document
    stats = fill_document_with_annotations(
        df=result_df,
        doc_path=r"data\TC5340_AskFinance_v1.0_Documentation - Validation Report (Auto).docx",
        output_path="/mnt/user-data/outputs/filled_document.docx"
    )
    
    print("\n✓ Processing complete!")
