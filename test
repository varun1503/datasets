@mcp.tool()
def flight_agent_healthcheck():
    """Health check for Flight MCP server."""
    return {"status": "flight_mcp_ok"}
@mcp.tool()
def simulate_flight_booking(
    flight_id: str,
    user_id: str,
    total_price_usd: float,
):
    """
    Simulates flight booking.
    No DB write – returns confirmation only.
    """

    confirmation_id = f"BOOK-{flight_id}-{user_id}"

    return {
        "confirmation_id": confirmation_id,
        "flight_id": flight_id,
        "user_id": user_id,
        "amount_charged_usd": total_price_usd,
        "status": "confirmed",
    }

@mcp.tool()
def share_selected_flight(
    flight_id: str,
    departure_time: str,
    arrival_time: str,
    origin: str,
    destination: str,
):
    """
    Shares selected flight timing with Hotel and Cab agents.
    (Simulation only – no persistence)
    """
    return {
        "flight_id": flight_id,
        "departure_time": departure_time,
        "arrival_time": arrival_time,
        "origin": origin,
        "destination": destination,
        "status": "shared_with_hotel_and_cab",
    }
@mcp.tool()
def search_flights(
    origin: str,
    destination: str,
    cabin_class: str | None = None,
    max_price_usd: float | None = None,
    nonstop_only: bool = False,
    earliest_departure: str | None = None,
    latest_departure: str | None = None,
):
    """
    Search and rank flights using flight_master (master.csv).

    Respects:
    - Origin & destination
    - Cabin class (if available)
    - Budget
    - Non-stop preference
    - Time window (optional)
    """

    df = pd.read_csv("master.csv")

    # Base filter
    df = df[
        (df["service_type"] == "flight") &
        (df["origin"] == origin) &
        (df["destination"] == destination)
    ]

    # Budget filter
    if max_price_usd is not None:
        df = df[df["price_usd"] <= max_price_usd]

    # Cabin class (if column exists)
    if cabin_class and "cabin_class" in df.columns:
        df = df[df["cabin_class"] == cabin_class]

    # Non-stop preference (simple simulation)
    if nonstop_only and "stops" in df.columns:
        df = df[df["stops"] == 0]

    # Ranking logic: cheaper + higher rating
    df = df.sort_values(
        by=["price_usd", "rating"],
        ascending=[True, False],
    )

    # Return top results
    return df.head(5).to_dict(orient="records")
