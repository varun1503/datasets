from docx import Document
from docx.shared import Pt, Inches, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_BREAK
from docx.enum.table import WD_TABLE_ALIGNMENT, WD_ALIGN_VERTICAL
from docx.oxml import OxmlElement
from docx.oxml.ns import qn

import os
import json
import ast
from typing import Optional, Any
import pandas as pd

EMU_PER_INCH = 914400

# ======================= Basic text helpers =======================

def _bold_run(p, text, size=11):
    r = p.add_run(text)
    r.bold = True
    r.font.size = Pt(size)
    return r

def _normal_run(p, text, size=11):
    r = p.add_run(text)
    r.font.size = Pt(size)
    return r

def safe_json_loads(cell: Any):
    """Pass-through for dict/list; try json/literal for strings."""
    if isinstance(cell, (dict, list)) or cell is None:
        return cell
    if not isinstance(cell, str):
        return cell
    try:
        return json.loads(cell)
    except Exception:
        pass
    try:
        return ast.literal_eval(cell)
    except Exception:
        return cell

def _add_heading(doc: Document, text: str, size=12):
    p = doc.add_paragraph()
    _bold_run(p, text, size=size)

def _add_rfr_block(doc: Document, rfr_obj: Any):
    """
    Render an RFR section from a dict like {"Q1": "...", "Q2": "..."}.
    Also tolerates JSON-ish strings by parsing first.
    """
    rfr_obj = safe_json_loads(rfr_obj)
    if not rfr_obj:
        _normal_run(doc.add_paragraph(), "(No RFR provided)")
        return

    if isinstance(rfr_obj, dict):
        for k, v in rfr_obj.items():
            p_q = doc.add_paragraph()
            _bold_run(p_q, f"{str(k).strip()}: ", size=11)

            p_a = doc.add_paragraph()
            _bold_run(p_a, "Response: ", size=11)
            _normal_run(p_a, str(v).strip())
    else:
        _normal_run(doc.add_paragraph(), str(rfr_obj).strip())

def _as_finding_lines(x: Any):
    """Normalize findings to list[str]. Accepts list/dict/string/JSON-ish."""
    x = safe_json_loads(x)
    if x is None:
        return []
    if isinstance(x, list):
        return [str(it).strip() for it in x if str(it).strip()]
    if isinstance(x, dict):
        return [f"{k}: {v}" for k, v in x.items() if str(v).strip()]
    if isinstance(x, str):
        s = x.strip()
        return [s] if s else []
    return [str(x).strip()]

# ======================= Table styling helpers =======================

def _set_cell_bg(cell, hex_color: str = "000000"):
    """Set solid background fill for a cell via oXML."""
    tc_pr = cell._tc.get_or_add_tcPr()
    shd = tc_pr.find(qn('w:shd'))
    if shd is None:
        shd = OxmlElement('w:shd')
        tc_pr.append(shd)
    shd.set(qn('w:fill'), hex_color)     # background color
    shd.set(qn('w:val'), 'clear')        # no pattern
    shd.set(qn('w:color'), 'auto')

def _format_header_cell(cell):
    """White, bold, centered text for header cells."""
    cell.vertical_alignment = WD_ALIGN_VERTICAL.CENTER
    for p in cell.paragraphs:
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        for r in p.runs:
            r.font.bold = True
            r.font.color.rgb = RGBColor(255, 255, 255)
            r.font.size = Pt(11)

def _force_table_borders(table, color="000000", size=8):
    """Ensure visible grid borders even if 'Table Grid' style is unavailable."""
    tbl = table._tbl
    tblPr = tbl.tblPr or OxmlElement('w:tblPr')
    if tbl.tblPr is None:
        tbl.append(tblPr)
    borders = tblPr.find(qn('w:tblBorders'))
    if borders is None:
        borders = OxmlElement('w:tblBorders')
        tblPr.append(borders)
    for edge in ['top', 'left', 'bottom', 'right', 'insideH', 'insideV']:
        el = borders.find(qn(f'w:{edge}'))
        if el is None:
            el = OxmlElement(f'w:{edge}')
            borders.append(el)
        el.set(qn('w:val'), 'single')
        el.set(qn('w:sz'), str(size))
        el.set(qn('w:space'), '0')
        el.set(qn('w:color'), color)

# ======================= Findings table =======================

def _emu_to_inches(v):  # EMU -> inches
    return float(v) / EMU_PER_INCH

def _estimate_col_weight(series):
    """Heuristic weight = max string length in the column."""
    lengths = (series.fillna("").astype(str).map(len)).tolist()
    return max(lengths) if lengths else 1

def _nz(v: Any) -> str:
    """None/NaN -> '' ; string -> stripped; else -> str(..)."""
    if v is None:
        return ""
    s = str(v).strip()
    return "" if s.lower() == "nan" else s

def _add_findings_table(doc: Document, findings_df: Optional[pd.DataFrame]):
    if findings_df is None or len(findings_df) == 0:
        return

    # Normalize / pick columns
    colmap = {str(c).lower().strip(): c for c in findings_df.columns}
    def pick(*aliases):
        for a in aliases:
            if str(a).lower() in colmap:
                return colmap[str(a).lower()]
        return None

    c_q  = pick("IMVP question","imvp_question","imvp q","imvp")
    c_ic = pick("Finding Impact Category","impact category","finding impact category","impact")
    c_fd = pick("Finding Details","finding detail","details","finding details")
    c_fs = pick("Finding Status","status","finding status")
    cols = [c_q, c_ic, c_fd, c_fs]
    headers = ["IMVP Question","Finding Impact Category","Finding Details","Finding Status"]
    if not all(cols):
        p = doc.add_paragraph()
        r = p.add_run("Findings (required columns missing)")
        r.bold = True
        return

    # Section + caption
    sec = doc.add_paragraph()
    sr = sec.add_run("Findings")
    sr.bold = True
    sr.font.size = Pt(12)

    cap = doc.add_paragraph("Summary of Findings")
    cap.alignment = WD_ALIGN_PARAGRAPH.CENTER
    cap.runs[0].bold = True
    cap.runs[0].font.size = Pt(12)

    # Build table
    table = doc.add_table(rows=1, cols=4)
    table.alignment = WD_TABLE_ALIGNMENT.CENTER
    table.autofit = False
    _force_table_borders(table, "000000")

    # Header row
    hdr = table.rows[0].cells
    for i, h in enumerate(headers):
        hdr[i].text = h
        _set_cell_bg(hdr[i], "000000")
        _format_header_cell(hdr[i])

    # Compute dynamic widths
    secn = doc.sections[-1]
    usable_in = _emu_to_inches(secn.page_width - secn.left_margin - secn.right_margin)

    # Heuristic weights from content
    weights = [
        _estimate_col_weight(findings_df[cols[0]]),
        _estimate_col_weight(findings_df[cols[1]]),
        _estimate_col_weight(findings_df[cols[2]]),
        _estimate_col_weight(findings_df[cols[3]]),
    ]
    if sum(weights) == 0:
        weights = [1, 1, 2, 1]

    # Min/Max guards (inches)
    min_w = [1.2, 1.4, 2.4, 1.2]
    max_w = [2.0, 2.4, 5.0, 2.0]

    raw = [w / sum(weights) * usable_in for w in weights]
    clamped = [max(min_w[i], min(max_w[i], raw[i])) for i in range(4)]
    total = sum(clamped)
    if total != 0 and abs(total - usable_in) > 1e-3:
        scale = usable_in / total
        clamped = [max(min_w[i], min(max_w[i], clamped[i] * scale)) for i in range(4)]

    # Apply widths
    for i, w_in in enumerate(clamped):
        for cell in table.columns[i].cells:
            cell.width = Inches(w_in)

    # Data rows
    for _, r in findings_df.iterrows():
        row_cells = table.add_row().cells
        row_cells[0].text = _nz(r.get(cols[0], ""))
        row_cells[1].text = _nz(r.get(cols[1], ""))
        row_cells[2].text = _nz(r.get(cols[2], ""))
        row_cells[3].text = _nz(r.get(cols[3], ""))
        for c in row_cells:
            c.vertical_alignment = WD_ALIGN_VERTICAL.CENTER
            for p in c.paragraphs:
                p.alignment = WD_ALIGN_PARAGRAPH.LEFT
                for run in p.runs:
                    run.font.size = Pt(10)

    doc.add_paragraph()  # spacer

# ======================= Findings by Section (from Risk Pillar) =======================

def _add_section_from_pillar_with_details(doc: Document, findings_df: Optional[pd.DataFrame]):
    """
    Group by the 'Risk Pillar' column.
    For each unique value, add a heading: 'Section: <pillar value>'
    and bullet ONLY the 'Finding Details' entries under it.
    """
    if findings_df is None or len(findings_df) == 0:
        return

    # tolerant column lookup
    colmap = {str(c).strip().lower(): c for c in findings_df.columns}
    def pick(*aliases):
        for a in aliases:
            k = str(a).strip().lower()
            if k in colmap:
                return colmap[k]
        return None

    c_pillar  = pick("risk pillar", "pillar")                  # heading source
    c_details = pick("finding details", "finding detail", "details")  # bullets

    if not c_pillar or not c_details:
        p = doc.add_paragraph()
        msg = "Findings by Section (from Risk Pillar) requires columns: "
        missing = []
        if not c_pillar:  missing.append("Risk Pillar")
        if not c_details: missing.append("Finding Details")
        _bold_run(p, msg + ", ".join(missing))
        return

    # Title
    title_p = doc.add_paragraph()
    tr = title_p.add_run("Findings by Section")
    tr.bold = True
    tr.font.size = Pt(12)

    # stable order by pillar
    df_sorted = findings_df.sort_values([c_pillar], kind="stable")

    for pillar_val, grp in df_sorted.groupby(c_pillar, dropna=False):
        # Heading = "Section: <pillar_val>"
        h = doc.add_paragraph()
        label = f"Section: {str(pillar_val).strip() if pd.notna(pillar_val) else 'Unspecified'}"
        _bold_run(h, label, size=11)

        # bullets = ONLY Finding Details; dedupe while preserving first occurrence
        seen = set()
        for _, row in grp.iterrows():
            detail = str(row.get(c_details, "") or "").strip()
            if not detail or detail in seen:
                continue
            seen.add(detail)

            p = doc.add_paragraph()
            try:
                p.style = doc.styles['List Bullet']
            except Exception:
                pass
            _normal_run(p, detail, size=10)

        # spacer after each section
        doc.add_paragraph()

# ======================= Title + (optional) TOC at very top =======================

def _insert_page_break_before(anchor_para):
    """Insert a page break immediately before `anchor_para`."""
    p = anchor_para.insert_paragraph_before()
    run = p.add_run()
    run.add_break(WD_BREAK.PAGE)

def _insert_paragraph_before(anchor_para, text="", bold=False, align=None, font_size_pt=None, left_indent_in=None):
    """Insert a formatted paragraph immediately before `anchor_para`."""
    p = anchor_para.insert_paragraph_before(text)
    if p.runs and bold:
        p.runs[0].bold = True
    if p.runs and font_size_pt:
        p.runs[0].font.size = Pt(font_size_pt)
    if align is not None:
        p.alignment = align
    if left_indent_in is not None:
        p.paragraph_format.left_indent = Inches(left_indent_in)
    return p

def _gather_toc_lines(toc_node, level=0):
    """Depth-first traversal of toc_dict -> list of (text, level)."""
    lines = []
    if isinstance(toc_node, dict):
        for heading, child in toc_node.items():
            lines.append((str(heading), level))
            if isinstance(child, dict) and child:
                lines.extend(_gather_toc_lines(child, level+1))
    return lines

def add_title_and_toc_at_top(
    doc: Document,
    model: str,
    impact: str,
    scope: str,
    model_id: str,
    model_version: str,
    model_name: str,
    report_date: str,
    toc_dict: dict,
):
    """
    Insert at the very start in CORRECT visual order:
      Title, Subtitle, Spacer,
      Page Break,
      'Table of Contents' heading,
      TOC items (top -> bottom),
      Page Break,
      then original prepend content.
    """
    # Ensure anchor
    if doc.paragraphs:
        anchor = doc.paragraphs[0]
    else:
        doc.add_paragraph()
        anchor = doc.paragraphs[0]

    # 1) Title
    title_text = (
        f"Model ID: {model_id}, "
        f"Model Version: {model_version}, "
        f"Model Name: {model_name}, "
        f"Date of Report Generation: {report_date}"
    )
    _insert_paragraph_before(
        anchor_para=anchor,
        text=title_text,
        bold=True,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=16
    )
    # 2) Subtitle
    _insert_paragraph_before(
        anchor_para=anchor,
        text=f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}",
        bold=False,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=11
    )
    # 3) Spacer
    _insert_paragraph_before(anchor_para=anchor, text="")

    # 4) Page break (between title and TOC)
    _insert_page_break_before(anchor)

    # 5) TOC heading
    _insert_paragraph_before(
        anchor_para=anchor,
        text="Table of Contents",
        bold=True,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=14
    )

    # 6) TOC items in NATURAL ORDER (no reversed)
    toc_lines = _gather_toc_lines(toc_dict, level=0)
    for text, level in toc_lines:
        _insert_paragraph_before(
            anchor_para=anchor,
            text=text,
            bold=False,
            align=None,
            font_size_pt=11,
            left_indent_in=0.25 * level  # indent per level
        )

    # 7) Page break (after TOC, before original content)
    _insert_page_break_before(anchor)

def add_title_only_top(
    doc: Document,
    model: str,
    impact: str,
    scope: str,
    model_id: str,
    model_version: str,
    model_name: str,
    report_date: str,
):
    """Insert only the title + subtitle at the very top (no TOC)."""
    if doc.paragraphs:
        anchor = doc.paragraphs[0]
    else:
        doc.add_paragraph()
        anchor = doc.paragraphs[0]

    _insert_paragraph_before(anchor_para=anchor, text="")  # spacer
    _insert_paragraph_before(
        anchor_para=anchor,
        text=f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}",
        bold=False,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=11
    )
    title_text = (
        f"Model ID: {model_id}, "
        f"Model Version: {model_version}, "
        f"Model Name: {model_name}, "
        f"Date of Report Generation: {report_date}"
    )
    _insert_paragraph_before(
        anchor_para=anchor,
        text=title_text,
        bold=True,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=16
    )

# ======================= Main =======================

def build_simple_template(
    df: pd.DataFrame,
    model: str,
    impact: str,
    model_id: str,
    model_version: str,
    model_name: str,
    report_date: str,
    prepend_docx_path: str,
    *,
    toc_dict: Optional[dict] = None,           # optional TOC dict
    scope: str = "",
    save_dir: str = "base",
    findings_df: Optional[pd.DataFrame] = None,   # Excel findings df
    question_col: str = "text",
    sections_col: str = "sections",
    mrmg_col: Optional[str] = "mrmg_answer",
    heading_col: Optional[str] = None,
    rfr_col: str = "RFR",
    finding_col: Optional[str] = "Findings",
    blank_lines_under_mtr: int = 2
) -> str:
    # sanity
    for col in [question_col, sections_col]:
        if col not in df.columns:
            raise KeyError(f"Missing required column: {col}")

    os.makedirs(save_dir, exist_ok=True)
    out_path = os.path.join(save_dir, f"{model}_{impact}{('_' + scope) if scope else ''}.docx")

    # Start from prepend template, or empty doc if not provided
    doc = Document(prepend_docx_path) if prepend_docx_path else Document()

    # Title (+ optional TOC) at the very top (keeps prepend content after TOC if present)
    if toc_dict:
        add_title_and_toc_at_top(
            doc=doc,
            model=model,
            impact=impact,
            scope=scope,
            model_id=model_id,
            model_version=model_version,
            model_name=model_name,
            report_date=report_date,
            toc_dict=toc_dict
        )
    else:
        add_title_only_top(
            doc=doc,
            model=model,
            impact=impact,
            scope=scope,
            model_id=model_id,
            model_version=model_version,
            model_name=model_name,
            report_date=report_date
        )

    # Findings summary table
    _add_findings_table(doc, findings_df)

    # Grouped view — Findings by Section (Section = Risk Pillar value; bullets = only Finding Details)
    _add_section_from_pillar_with_details(doc, findings_df)

    # Rows for Q/A, Sections, RFR, etc.
    for i, row in df.iterrows():
        # Question
        pq = doc.add_paragraph()
        _bold_run(pq, f"Question {i+1}: ", size=12)
        _normal_run(pq, str(row[question_col]).strip())
        doc.add_paragraph()

        # Section
        ps = doc.add_paragraph()
        _bold_run(ps, "Section: ")
        _normal_run(ps, str(row[sections_col]).strip())
        doc.add_paragraph()

        # Optional Heading
        if heading_col and heading_col in df.columns:
            ph = doc.add_paragraph()
            _bold_run(ph, "Heading: ")
            _normal_run(ph, str(row.get(heading_col, "")).strip())
            doc.add_paragraph()

        # MRMG Assessment (if present)
        if mrmg_col and mrmg_col in df.columns:
            pm = doc.add_paragraph()
            _bold_run(pm, "MRMG Assessment: ")
            _normal_run(pm, str(row.get(mrmg_col, "")).strip())
            doc.add_paragraph()

        # RFR
        if rfr_col in df.columns:
            _add_heading(doc, "RFR", size=12)
            _add_rfr_block(doc, row.get(rfr_col))

        # Findings (per-question list, if still desired)
        if finding_col and finding_col in df.columns:
            _add_heading(doc, "Findings", size=12)
            lines = _as_finding_lines(row.get(finding_col))
            if lines:
                for line in lines:
                    p = doc.add_paragraph()
                    try:
                        p.style = doc.styles['List Bullet']
                    except Exception:
                        pass
                    _normal_run(p, line)
            else:
                _normal_run(doc.add_paragraph(), "(No findings provided)")

        # Modelling Team Response (space)
        pmt = doc.add_paragraph()
        _bold_run(pmt, "Modelling Team Response", size=11)
        for _ in range(max(0, blank_lines_under_mtr)):
            doc.add_paragraph()
        # spacer
        doc.add_paragraph()

    doc.save(out_path)
    return out_path

# df_main = ...        # your Q/A dataframe
# findings_df = ...    # must include columns: "Risk Pillar" and "Finding Details"
# toc_dict = {...}     # or None to skip TOC

out_file = build_simple_template(
    df=df_main,
    model="IVR Model",
    impact="High",
    model_id="M-123",
    model_version="v2.1",
    model_name="IVR Intent Classifier",
    report_date="2025-09-25",
    prepend_docx_path="path/to/prepend.docx",
    toc_dict=toc_dict,          # pass dict or None
    scope="India",
    save_dir="base",
    findings_df=findings_df,
    question_col="text",
    sections_col="sections",
    mrmg_col="mrmg_answer",
    heading_col=None,
    rfr_col="RFR",
    finding_col="Findings",
    blank_lines_under_mtr=2
)
print("Saved:", out_file)
