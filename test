from docx import Document
from docx.text.paragraph import Paragraph
from docx.oxml import OxmlElement
from docx.shared import Pt
from docx.enum.text import WD_COLOR_INDEX
import re, json, ast
import pandas as pd
from docx.oxml.ns import qn
from docx.oxml.table import CT_Tbl
import codecs

def preprocess_mrmg_text(text: str) -> str:
    """
    Clean MRMG Assessment text before inserting:
    - Decodes unicode escape sequences like '\u2019'
    - Replaces escaped \n with real newlines
    - Strips extra whitespace
    - Normalizes bullets or special formatting
    """
    if not isinstance(text, str):
        return ""

    # Decode unicode escape sequences (e.g., \u2019 → ')
    try:
        text = codecs.decode(text.encode("utf-8"), "unicode_escape")
    except Exception:
        pass  # if decoding fails, skip

    # Replace literal '\n' strings with real newlines
    text = text.replace("\\n", "\n")

    # Normalize space
    text = re.sub(r"[ \t]+", " ", text)
    text = re.sub(r"\n\s+", "\n", text)
    text = text.strip()

    return text

def _norm(s):
    return re.sub(r"\s+", " ", (s or "")).strip().lower()

def _format_run(run, bold=False, highlight=None):
    run.bold = bool(bold)
    run.font.name = "Times New Roman"
    run.font.size = Pt(11)
    if highlight is not None:
        run.font.highlight_color = highlight

def _insert_after_para(p: Paragraph, text="", bold=False, highlight=None):
    new_p = OxmlElement("w:p")
    p._p.addnext(new_p)
    q = Paragraph(new_p, p._parent)
    if text:
        r = q.add_run(text)
        _format_run(r, bold=bold, highlight=highlight)
    return q

def _safe_dict(x):
    if isinstance(x, dict):
        return x
    if isinstance(x, str):
        s = x.strip()
        if not s:
            return {}
        try:
            return json.loads(s)
        except Exception:
            try:
                return ast.literal_eval(s)
            except Exception:
                return {}
    return {}

def _snum(text):
    """Extract S number with optional letter suffix (S14, S14A, etc.)"""
    m = re.search(r"\bS\s*(\d+[A-Za-z]?)\b", text or "", flags=re.IGNORECASE)
    return f"S{m.group(1)}" if m else ""

def _set_paragraph_text(p: Paragraph, text: str, bold=False):
    for r in p.runs:
        r.text = ""
    r = p.add_run(text)
    _format_run(r, bold=bold, highlight=None)

def _is_heading_style(p: Paragraph):
    """Check if paragraph uses a Word heading style"""
    try:
        return p.style and p.style.name and "heading" in p.style.name.lower()
    except Exception:
        return False

def _is_content_heading(p: Paragraph):
    """
    Detect if a paragraph is a heading based on content patterns:
    - Test S#, Test S#A, Test-S#, T-S#
    - MRMG Assessment S#, MRMG Evaluation S#
    - RFR S#
    - Or any bold paragraph that looks like a section heading
    """
    text = _norm(p.text)
    
    if not text:
        return False
    
    # Check for common heading patterns
    heading_patterns = [
        r'^test[\s-]+s\d+[a-z]?',                          # Test S14, Test-S14, Test S14A
        r'^t[\s-]+s\d+[a-z]?',                             # T-S14, T S14A
        r'^mrmg\s+(assessment|evaluation)\s+s\d+[a-z]?',   # MRMG Assessment S14
        r'^rfr\s+s\d+[a-z]?',                              # RFR S14
        r'^s\d+[a-z]?\s*:',                                # S14:, S14A:
        r'^section\s+s?\d+[a-z]?',                         # Section 14, Section S14A
    ]
    
    for pattern in heading_patterns:
        if re.match(pattern, text):
            return True
    
    # Check if paragraph is bold and short (likely a heading)
    if p.runs:
        try:
            # Check if all non-empty runs are bold
            non_empty_runs = [run for run in p.runs if run.text.strip()]
            if non_empty_runs:
                is_bold = all(run.bold for run in non_empty_runs)
                is_short = len(text) < 100
                # Check if it contains an S number pattern
                if is_bold and is_short and re.search(r's\d+[a-z]?\b', text):
                    return True
        except Exception:
            pass
    
    return False

def _delete_content_after_paragraph(paragraph, stop_on_heading=True, DEBUG=False):
    """
    Delete all content after the given paragraph — including tables —
    until the next heading (styled or content-based)
    """
    current = paragraph._p
    deleted_count = 0
    
    while True:
        next_elem = current.getnext()
        if next_elem is None:
            break

        # Stop if next paragraph is a styled heading or content heading
        if stop_on_heading and next_elem.tag == qn("w:p"):
            next_para = Paragraph(next_elem, paragraph._parent)
            
            # Check both style-based and content-based headings
            if _is_heading_style(next_para) or _is_content_heading(next_para):
                if DEBUG:
                    print(f"[INFO] Stopped deletion at heading: '{next_para.text[:50]}'")
                break

        # Remove the element (paragraph, table, or other block)
        current.getparent().remove(next_elem)
        deleted_count += 1
    
    if DEBUG:
        print(f"[INFO] Deleted {deleted_count} elements after paragraph")

def insert_rfr_and_mrmg_with_tags(
    doc_path: str,
    df: pd.DataFrame,
    output_path: str,
    tag_col: str = "text",
    rfr_col: str = "rfr_value",
    mrmg_col: str = "MRMG Assessment",
    highlight_assessment: bool = True,
    assessment_highlight_color=WD_COLOR_INDEX.YELLOW,
    DEBUG=False,
):
    """
    Insert RFR values and MRMG assessments into a Word document based on tags.
    
    Args:
        doc_path: Path to input Word document
        df: DataFrame containing tags and assessments
        output_path: Path to save modified document
        tag_col: Column name containing section tags (e.g., "Test S14")
        rfr_col: Column name containing RFR values
        mrmg_col: Column name containing MRMG assessments
        highlight_assessment: Whether to highlight inserted assessments
        assessment_highlight_color: Color for highlighting
        DEBUG: Enable debug output
    """
    doc = Document(doc_path)
    
    if DEBUG:
        print(f"\n[INFO] Processing {len(df)} rows from DataFrame")
        print(f"[INFO] Document has {len(doc.paragraphs)} paragraphs")

    for idx, row in df.iterrows():
        tag = str(row.get(tag_col, "") or "").strip()
        raw_text = str(row.get(mrmg_col, "") or "").strip()
        mrmg_new = preprocess_mrmg_text(raw_text)

        if not tag:
            if DEBUG:
                print(f"\n[WARN] Row {idx}: Empty tag, skipping")
            continue

        sn = _snum(tag)
        
        if DEBUG:
            print(f"\n[INFO] Row {idx}: Processing tag='{tag}', SN='{sn}'")
        
        paras = doc.paragraphs

        # 1. Locate the paragraph that contains the tag (Test S6 etc.)
        start_idx = next((i for i, p in enumerate(paras) if tag.lower() in _norm(p.text)), None)
        if start_idx is None and sn:
            start_idx = next((i for i, p in enumerate(paras) if sn.lower() in _norm(p.text)), None)
        
        if start_idx is None:
            if DEBUG:
                print(f"[WARN] No match found in document for tag '{tag}'")
            continue
        
        if DEBUG:
            print(f"[INFO] Found tag at paragraph {start_idx}: '{paras[start_idx].text[:60]}'")

        # 2. Find MRMG Assessment S# heading
        def _is_mrmg_heading(p):
            normalized = _norm(p.text)
            return (normalized.startswith("mrmg assessment") or normalized.startswith("mrmg evaluation")) and sn.lower() in normalized

        mrmg_idx = next((i for i in range(start_idx, len(paras)) if _is_mrmg_heading(paras[i])), None)
        
        if mrmg_idx is None:
            if DEBUG:
                print(f"[WARN] No MRMG heading found for {sn}")
            continue
        
        if DEBUG:
            print(f"[INFO] Found MRMG heading at paragraph {mrmg_idx}: '{paras[mrmg_idx].text}'")

        # 3. Normalize heading text (remove colon / inline text)
        m = re.match(r"^(mrmg assessment(?:\s*s?\d+[a-z]?)?)(:.*)?$", paras[mrmg_idx].text.strip(), flags=re.IGNORECASE)
        
        if m:
            _set_paragraph_text(paras[mrmg_idx], m.group(1), bold=True)
        else:
            m = re.match(r"^(mrmg evaluation(?:\s*s?\d+[a-z]?)?)(:.*)?$", paras[mrmg_idx].text.strip(), flags=re.IGNORECASE)
            if m:
                _set_paragraph_text(paras[mrmg_idx], m.group(1), bold=True)

        # 4. Preview next heading before deletion (for debugging)
        if DEBUG:
            print(f"[INFO] Scanning for next heading after MRMG...")
            for i in range(mrmg_idx + 1, min(mrmg_idx + 20, len(paras))):
                if _is_heading_style(paras[i]) or _is_content_heading(paras[i]):
                    print(f"[INFO] Next heading detected at paragraph {i}: '{paras[i].text[:60]}'")
                    break

        # 5. Delete everything after MRMG heading (including tables) until next heading
        if DEBUG:
            print(f"[INFO] Removing content after MRMG heading...")
        
        _delete_content_after_paragraph(paras[mrmg_idx], stop_on_heading=True, DEBUG=DEBUG)
        paras = doc.paragraphs  # refresh after deletion

        # 6. Insert updated MRMG body
        new_body = _insert_after_para(
            paras[mrmg_idx],
            text=mrmg_new,
            bold=False,
            highlight=(assessment_highlight_color if highlight_assessment else None),
        )
        _insert_after_para(new_body, "")  # spacer
        
        if DEBUG:
            print(f"[INFO] Inserted MRMG content ({len(mrmg_new)} chars)")

    doc.save(output_path)
    
    if DEBUG:
        print(f"\n[SUCCESS] Document saved to: {output_path}")


# Example usage
if __name__ == "__main__":
    # Sample DataFrame
    sample_data = {
        "text": ["Test S14", "Test S14A", "Test S15"],
        "MRMG Assessment": [
            "This is assessment for S14...",
            "This is assessment for S14A...",
            "This is assessment for S15..."
        ],
        "rfr_value": ["RFR1", "RFR2", "RFR3"]
    }
    
    df = pd.DataFrame(sample_data)
    
    # Process document
    insert_rfr_and_mrmg_with_tags(
        doc_path="input.docx",
        df=df,
        output_path="output.docx",
        DEBUG=True  # Enable debug output
    )
