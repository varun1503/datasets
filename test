import re
import json
import unicodedata
from pathlib import Path
from typing import List, Dict

from docx import Document
from docx.oxml.ns import qn
from docx.text.paragraph import Paragraph
from docx.table import Table


# ==================== NORMALIZATION ====================

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


# ==================== DOCX READING ====================

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                row_text = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            row_text.append(t)
                if row_text:
                    lines.append(" ".join(row_text))

    return lines


# ==================== HELPERS ====================

BRACKET_BLOCK_RX = re.compile(r"<\s*([^>]+?)\s*>")
TEST_RX = re.compile(r"Test\s*S(\d+)", re.IGNORECASE)
F_RX = re.compile(r"F\d+\s*:\s*(.*)", re.IGNORECASE)
Q_RX = re.compile(r"Q\d+\s*:\s*(.*)", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modell?ing Team['’]?s Response", re.IGNORECASE)


# ==================== CORE PARSER ====================

def parse_doc(lines: List[str]) -> List[Dict]:
    rows = []
    i = 0

    while i < len(lines):
        line = lines[i]

        if "RFR" in line:
            blocks = [norm(b) for b in BRACKET_BLOCK_RX.findall(line)]

            rfr_q = ""
            section = ""
            imvp = ""
            test_tags = []
            current_f = None

            # ---- classify header blocks ----
            for b in blocks:
                if Q_RX.match(b):
                    rfr_q = Q_RX.match(b).group(1).strip()
                elif b.endswith("?"):
                    imvp = b
                elif TEST_RX.search(b):
                    test_tags.append(f"tests{TEST_RX.search(b).group(1)}")
                elif F_RX.match(b):
                    current_f = F_RX.match(b).group(1).strip("–- ").strip()
                elif not section and len(b.split()) <= 5:
                    section = b

            # ---- read response ----
            response = ""
            j = i + 1
            while j < len(lines):
                if RESP_HDR_RX.search(lines[j]):
                    k = j + 1
                    while k < len(lines):
                        if "<" in lines[k]:
                            response = norm(re.sub(r"[<>]", "", lines[k]))
                            break
                        k += 1
                    break
                j += 1

            rfr_payload = (
                {current_f: response} if current_f else response
            )

            row = {
                "IMVP Question": imvp,
                "Section": section,
                "rfr": {rfr_q: rfr_payload}
            }

            for t in test_tags:
                row[t] = imvp

            rows.append(row)
            i = j
            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"

    lines = read_docx_lines(DOCX_PATH)
    rows = parse_doc(lines)

    print(json.dumps(rows, indent=2, ensure_ascii=False))


if __name__ == "__main__":
    main()
