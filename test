from __future__ import annotations
from dataclasses import dataclass, field
from typing import List, Dict, Pattern, Tuple, Optional
import os, re
from fuzzywuzzy import fuzz
from fuzzysearch import find_near_matches


@dataclass
class BasicChecks:
    # Tunables
    max_l_dist: int = 1
    decline_lead_1: str = "Here's the reason we made the decision"
    decline_lead_2: str = "Reason(s) for Our Decision"
    ecoa_string: str = "The federal Equal Credit Opportunity Act"
    continued_filler_next: str = "Continued  on  next  page"

    credit_bureau_list: List[str] = field(default_factory=lambda: [
        "Experian",
        "D&B corporation",
        "TransUnion Consumer Relations",
        "LexisNexis Risk Solutions Bureau LLC"
    ])

    date_regex: Pattern[str] = re.compile(
        r"(?:January|February|March|April|May|June|July|August|September|October|November|December)"
        r"\s+(?:[1-9]|[12]\d|3[01]),?\s+\d{4}"
    )

    # ---------- Helpers ----------
    @staticmethod
    def sentence_split(text: str) -> List[str]:
        out, cur = [], []
        for ch in text:
            cur.append(ch)
            if ch in [".", ",", "!", "\n", "?"]:
                out.append("".join(cur).strip())
                cur = []
        if cur:
            out.append("".join(cur).strip())
        return [s for s in out if s]

    @staticmethod
    def slice_next_sentences(content: str, start_idx: int, n_sentences: int) -> str:
        if start_idx < 0 or start_idx >= len(content):
            return ""
        tail = re.sub(r"[ \t]+", " ", content[start_idx:])
        parts = re.split(r"(?<=[\.!?])\s+", tail)
        return " ".join(parts[:max(1, n_sentences)]).strip()

    @staticmethod
    def list_file_paths(folder_path: str) -> List[str]:
        acc = []
        for root, _, files in os.walk(folder_path):
            for f in files:
                if f.lower().endswith(".txt"):
                    acc.append(os.path.abspath(os.path.join(root, f)))
        return acc

    # ---------- Finders ----------
    def find_action(self, content: str, threshold: int = 50) -> Optional[Tuple[str, int]]:
        target = "unable cannot approve your at this time"
        for sent in self.sentence_split(content):
            score = fuzz.ratio(target, sent)
            if score > threshold:
                return sent.strip(), score
        return None

    def find_decline_reason(self, content: str) -> str:
        r1 = find_near_matches(self.decline_lead_1, content, max_l_dist=self.max_l_dist)
        r2 = find_near_matches(self.decline_lead_2, content, max_l_dist=self.max_l_dist)
        if not r1 and not r2:
            return "not found"
        start = (r1 or r2)[0].start
        return self.slice_next_sentences(content, start, 15)

    def find_ecoa(self, content: str) -> str:
        hits = find_near_matches(self.ecoa_string, content, max_l_dist=self.max_l_dist)
        if not hits:
            return "not found"
        s = hits[0].start
        block = self.slice_next_sentences(content, s, 10)
        if self.continued_filler_next in block:
            block = self.slice_next_sentences(content, s, 17)
        return block

    def find_federal_agency(self, content: str) -> str:
        phrase = "The federal agency that administers compliance with this law concerning"
        hits = find_near_matches(phrase, content, max_l_dist=self.max_l_dist)
        if not hits:
            return "not found"
        s = hits[0].start
        return self.slice_next_sentences(content, s, 3)

    @staticmethod
    def should_check_fico(text: str, dcsn_rsn_cd: str) -> bool:
        return ("FICO score" in text) or (dcsn_rsn_cd.lower() == "d2f")

    def get_credit_bureaus(self, content: str) -> List[str]:
        return [item for item in self.credit_bureau_list if item in content]

    def find_second_date_if_bureau(self, content: str) -> str:
        if not self.get_credit_bureaus(content):
            return "not found"
        dates = re.findall(self.date_regex, content)
        if len(dates) <= 1:
            return "not found"
        return dates[1]

    def find_fico_score(self, content: str) -> str:
        if not self.get_credit_bureaus(content):
            return "not found (no bureau)"
        hits = find_near_matches("FICO score was", content, max_l_dist=self.max_l_dist)
        if not hits:
            return "not found"
        s = hits[0].start
        return self.slice_next_sentences(content, s, 3)

    def find_factors(self, content: str) -> str:
        if not self.get_credit_bureaus(content):
            return "not found (no bureau)"
        phrase = "the key factors that contrubuted to your FICO score"
        hits = find_near_matches(phrase, content, max_l_dist=self.max_l_dist)
        if not hits:
            return "not found"
        s = hits[0].start
        return self.slice_next_sentences(content, s, 8)

    def best_sentence_for_keywords(self, content: str, keywords: List[str], min_score: int = 60) -> Dict[str, str]:
        sentences = self.sentence_split(content)
        results: Dict[str, str] = {}
        for kw in keywords:
            best = ("", -1)
            for s in sentences:
                sc = fuzz.partial_ratio(kw.lower(), s.lower())
                if sc > best[1]:
                    best = (s.strip(), sc)
            results[kw] = f"{best[0]} (score={best[1]})" if best[1] >= min_score else "not found"
        return results

    # ---------- Analyze ----------
    def analyze_file(self, file_path: str, dcsn_rsn_cd: str = "") -> Dict[str, str]:
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read()

        action_hit = self.find_action(content)
        decline = self.find_decline_reason(content)
        ecoa = self.find_ecoa(content)
        agency = self.find_federal_agency(content)
        bureaus = self.get_credit_bureaus(content)
        date2 = self.find_second_date_if_bureau(content)
        fico_score = self.find_fico_score(content) if self.should_check_fico(content, dcsn_rsn_cd) else "skipped"
        factors = self.find_factors(content)
        best_map = self.best_sentence_for_keywords(content, ["adequacy", "accuracy", "accurate"], 60)

        return {
            "Action Sentence": f"{action_hit[0]} (ratio={action_hit[1]})" if action_hit else "not found",
            "Decline Reason": decline,
            "ECOA Section": ecoa,
            "Federal Agency": agency,
            "Credit Bureaus": ", ".join(bureaus) if bureaus else "not found",
            "2nd Date (if bureau)": date2,
            "FICO Score": fico_score,
            "FICO Factors": factors,
            "Best: adequacy": best_map["adequacy"],
            "Best: accuracy": best_map["accuracy"],
            "Best: accurate": best_map["accurate"],
        }

    def _format_report(self, file_path: str, info: Dict[str, str]) -> str:
        lines = [f"FILE: {file_path}"]
        for k, v in info.items():
            if not k.startswith("Best"):
                lines.append(f"{k}: {v}")
        lines.append("")
        lines.append("=== BEST MATCH SENTENCES ===")
        for k in ["Best: adequacy", "Best: accuracy", "Best: accurate"]:
            lines.append(f"{k.replace('Best: ', '').capitalize()}: {info[k]}")
        return "\n".join(lines)

    @staticmethod
    def _unique_path(path: str) -> str:
        if not os.path.exists(path):
            return path
        root, ext = os.path.splitext(path)
        i = 1
        while True:
            new_path = f"{root}-{i}{ext}"
            if not os.path.exists(new_path):
                return new_path
            i += 1

    # ---------- Batch run ----------
    def run(self, input_folder: str, output_folder: str, dcsn_rsn_cd: str = "") -> None:
        os.makedirs(output_folder, exist_ok=True)
        files = self.list_file_paths(input_folder)
        for fp in files:
            try:
                info = self.analyze_file(fp, dcsn_rsn_cd)
                report = self._format_report(fp, info)
                out_path = os.path.join(output_folder, os.path.splitext(os.path.basename(fp))[0] + ".analysis.txt")
                out_path = self._unique_path(out_path)
                with open(out_path, "w", encoding="utf-8") as f:
                    f.write(report)
                print(f"✅ Saved report: {out_path}")
            except Exception as e:
                print(f"❌ Error processing {fp}: {e}")
        print(f"\nAll reports saved in: {output_folder}")
