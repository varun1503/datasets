import re
import json
import unicodedata
import os
from pathlib import Path
from typing import List, Dict, Optional
from collections import OrderedDict

import pandas as pd
from docx import Document
from docx.oxml.ns import qn
from docx.table import Table
from docx.text.paragraph import Paragraph


# ==================== TEXT NORMALIZATION ====================

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


# ==================== DOCX READING ====================

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines: List[str] = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                cells = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            cells.append(t)
                if cells:
                    lines.append(" | ".join(cells))

    return lines


# ==================== REGEX ====================

REQ_ITEMS_RX = re.compile(r"Request\s+Items", re.IGNORECASE)
RFR_RX = re.compile(r"\bRFR\s*\d+", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modell?ing Team['’]?s Response", re.IGNORECASE)
BRACKETS_RX = re.compile(r"<\s*([^>]+?)\s*>")
Q_KEY_RX = re.compile(r"Q\d+\s*:", re.IGNORECASE)
TEST_TAG_RX = re.compile(r"<\s*Test\s*(\w+)\s*>", re.IGNORECASE)


# ==================== META EXTRACTION ====================

def extract_meta_from_rfr_header(line: str):
    parts = [norm(x) for x in BRACKETS_RX.findall(line)]

    rfr_q = ""
    section = ""
    imvp = ""

    for p in parts:
        if Q_KEY_RX.search(p):
            rfr_q = Q_KEY_RX.sub("", p).strip()
            break

    for p in parts:
        if p.endswith("?") and p != rfr_q:
            imvp = p

    for p in parts:
        if p != rfr_q and not p.endswith("?"):
            section = p
            break

    return rfr_q, section, imvp


def extract_test_tag(line: str) -> Optional[str]:
    m = TEST_TAG_RX.search(line)
    return f"test{m.group(1).lower()}" if m else None


# ==================== HELPERS ====================

def is_only_bullets(text: str) -> bool:
    t = text.lower()
    t = re.sub(r'\b[ivx]+\.', '', t)
    t = re.sub(r'\b[a-z]\)', '', t)
    return not t.strip()


def clean_f_key(text: str, fallback: str) -> str:
    if not text:
        return fallback
    if is_only_bullets(text):
        return fallback
    return text.strip()


# ==================== CORE PARSER ====================

def parse_lines_after_request_items(lines: List[str]) -> List[Dict]:
    start = 0
    for i, t in enumerate(lines):
        if REQ_ITEMS_RX.search(t):
            start = i + 1
            break

    L = lines[start:]
    rows = []
    i = 0

    while i < len(L):
        line = L[i]

        if RFR_RX.search(line):
            rfr_q, section, imvp = extract_meta_from_rfr_header(line)
            test_tag = extract_test_tag(line)

            f_items = {}
            direct_response = ""

            current_f = None
            in_block = False
            buffer = []
            collecting_question = False
            collecting_response = False

            i += 1

            while i < len(L) and not RFR_RX.search(L[i]):
                cur = L[i].strip()

                # RESPONSE HEADER
                if RESP_HDR_RX.search(cur):
                    collecting_question = False
                    collecting_response = True
                    i += 1
                    continue

                # OPEN <
                if cur.startswith("<"):
                    in_block = True
                    buffer = []

                    f_match = re.search(r'<\s*F(\d+)\s*:\s*(.*)', cur, re.IGNORECASE)
                    if f_match:
                        f_num = f"F{f_match.group(1)}"
                        f_text = clean_f_key(f_match.group(2).strip(), f_num)
                        current_f = f_text
                        f_items.setdefault(current_f, {"question": "", "response": ""})
                        collecting_question = True
                        collecting_response = False

                        rest = f_match.group(2).strip()
                        if rest:
                            buffer.append(rest)
                    i += 1
                    continue

                # CLOSE >
                if cur.startswith(">"):
                    content = norm(" ".join(buffer))
                    in_block = False

                    if collecting_question and current_f:
                        if not is_only_bullets(content):
                            f_items[current_f]["question"] = content
                        collecting_question = False

                    elif collecting_response:
                        if current_f:
                            f_items[current_f]["response"] = content
                        else:
                            direct_response = content
                        collecting_response = False

                    buffer = []
                    i += 1
                    continue

                # COLLECT
                if in_block:
                    buffer.append(cur)
                    i += 1
                    continue

                i += 1

            # FINALIZE
            q_responses = {}

            if f_items:
                for k, v in f_items.items():
                    if v.get("response"):
                        q_responses[k] = v["response"]
                    elif v.get("question"):
                        q_responses[k] = v["question"]

            elif direct_response:
                q_responses["response"] = direct_response

            if q_responses:
                row = {
                    "IMVP Question": imvp,
                    "Section": section,
                    "rfr": {rfr_q: q_responses},
                }
                if test_tag:
                    row[test_tag] = imvp
                rows.append(row)

            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"
    OUT_JSON = "rfr_rows.json"
    OUT_CSV = "rfr_rows.csv"

    if not Path(DOCX_PATH).exists():
        print("❌ DOCX file not found")
        return

    rows = parse_lines_after_request_items(read_docx_lines(DOCX_PATH))

    with open(OUT_JSON, "w", encoding="utf-8") as f:
        json.dump(rows, f, indent=2, ensure_ascii=False)

    df = pd.DataFrame({"finding": rows})
    df["file name"] = os.path.basename(DOCX_PATH)
    df["type"] = "rfr"
    df.to_csv(OUT_CSV, index=False)

    print("✅ Parsing completed successfully")


if __name__ == "__main__":
    main()
