# filename: build_validation_report.py

import os, re, json, ast, io, csv
from typing import Any, Optional, Tuple, List
import pandas as pd
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH


# =========================
# Parsing helpers
# =========================

def _df_from_list_list(rows: List[List[Any]]) -> Optional[pd.DataFrame]:
    if not rows:
        return None
    header = rows[0]
    data = rows[1:] if len(rows) > 1 else []
    if not all(isinstance(h, str) for h in header):
        header = [f"Col{j+1}" for j in range(len(header))]
    try:
        return pd.DataFrame(data, columns=header)
    except Exception:
        maxlen = max(len(r) for r in rows)
        header = header + [f"Col{j+1}" for j in range(len(header), maxlen)]
        data2 = [list(r) + [""]*(maxlen-len(r)) for r in data]
        return pd.DataFrame(data2, columns=header)

def _table_from_any(x) -> Optional[List[dict]]:
    """Coerce common shapes to list-of-dicts (good for CSV/JSON/Word table)."""
    try:
        if isinstance(x, str):
            s = x.strip()
            if not s:
                return None
            for loader in (json.loads, ast.literal_eval):
                try:
                    x = loader(s)
                    break
                except Exception:
                    pass
        if isinstance(x, dict):
            return [x]
        if isinstance(x, list) and x:
            if isinstance(x[0], dict):
                return x
            if isinstance(x[0], (list, tuple)):
                df = _df_from_list_list([list(r) for r in x])
                return None if df is None else json.loads(df.to_json(orient="records"))
            return json.loads(pd.DataFrame(x).to_json(orient="records"))
    except Exception:
        return None
    return None

# markdown/CSV/TSV block detectors inside free text
_md_table_block = re.compile(r"(?P<block>(?:^\s*\|.*\|\s*$\n?){2,})", re.MULTILINE)
_md_header_rule = re.compile(r"^\s*\|?\s*:?-{3,}:?\s*(\|\s*:?-{3,}:?\s*)+\|?\s*$")
_csvish_block = re.compile(r"(?P<block>(?:^[^\n,]*,[^\n]*\n){1,}[^\n,]*,[^\n]*$)", re.MULTILINE)
_tsv_block = re.compile(r"(?P<block>(?:^[^\n\t]*\t[^\n]*\n){1,}[^\n\t]*\t[^\n]*$)", re.MULTILINE)

def _detect_html_table(text: str) -> Optional[pd.DataFrame]:
    if "<table" in text.lower() and "</table>" in text.lower():
        try:
            tables = pd.read_html(text)  # needs lxml
            if tables:
                return tables[0]
        except Exception:
            return None
    return None

def _detect_markdown_table(text: str) -> Tuple[Optional[pd.DataFrame], str]:
    m = _md_table_block.search(text)
    if not m:
        return None, text
    block = m.group("block")
    lines = [ln.strip() for ln in block.strip().splitlines() if ln.strip()]
    if len(lines) < 2:
        return None, text
    if not any(_md_header_rule.match(ln) for ln in lines[1:3]):
        return None, text
    rows = []
    for ln in lines:
        if "|" not in ln:
            continue
        parts = [c.strip() for c in ln.strip().strip("|").split("|")]
        rows.append(parts)
    df = _df_from_list_list(rows)
    new_text = text.replace(block, "").strip()
    return df, new_text

def _detect_csv_table(text: str) -> Tuple[Optional[pd.DataFrame], str]:
    m = _csvish_block.search(text)
    if not m:
        return None, text
    block = m.group("block")
    try:
        reader = csv.reader(io.StringIO(block))
        rows = [row for row in reader if row]
        df = _df_from_list_list(rows)
        new_text = text.replace(block, "").strip()
        return df, new_text
    except Exception:
        return None, text

def _detect_tsv_table(text: str) -> Tuple[Optional[pd.DataFrame], str]:
    m = _tsv_block.search(text)
    if not m:
        return None, text
    block = m.group("block")
    rows = [ln.split("\t") for ln in block.strip().splitlines()]
    df = _df_from_list_list(rows)
    new_text = text.replace(block, "").strip()
    return df, new_text

def _detect_kv_grid(text: str) -> Tuple[Optional[pd.DataFrame], str]:
    # lines like "Metric: Recall"
    lines = [ln.strip() for ln in text.splitlines()]
    kv = []
    for ln in lines:
        if ":" in ln and not ln.lower().startswith("http"):
            left, right = ln.split(":", 1)
            if left.strip() and right.strip():
                kv.append([left.strip(), right.strip()])
    if len(kv) >= 2:
        df = pd.DataFrame(kv, columns=["Key", "Value"])
        rem = "\n".join(f"{k}: {v}" for k, v in kv)
        new_text = text.replace(rem, "").strip()
        return df, new_text
    return None, text

def _coerce_table_df_to_records(df: Optional[pd.DataFrame]) -> Optional[List[dict]]:
    if df is None or df.empty:
        return None
    return json.loads(df.to_json(orient="records"))

def _extract_text_and_table(val) -> Tuple[str, Optional[List[dict]]]:
    """
    Accept plain string, JSON/python dict/list, or mixed text+table blocks.
    Returns (clean_text_without_table, table_as_list_of_dicts_or_None)
    """
    # dict/list path
    if isinstance(val, dict):
        text = ""
        for k in ("modelling_team_answer", "answer", "text", "response"):
            if k in val and str(val[k]).strip():
                text = str(val[k]).strip()
                break
        tbl = None
        for tk in ("modelling_team_table", "table", "tables", "data"):
            if tk in val and val[tk]:
                tbl = _table_from_any(val[tk])
                break
        return text, tbl

    if isinstance(val, list):
        text, tbl = "", None
        for it in val:
            t, tb = _extract_text_and_table(it)
            if not text and t:
                text = t
            if tbl is None and tb:
                tbl = tb
            if text and tbl:
                break
        return text, tbl

    # string path
    if isinstance(val, str):
        s = val.strip()
        if not s:
            return "", None
        # try parse as JSON/python first
        for loader in (json.loads, ast.literal_eval):
            try:
                parsed = loader(s)
                return _extract_text_and_table(parsed)
            except Exception:
                pass

        # detect embedded tables in raw text
        df = _detect_html_table(s)
        if df is not None:
            s_wo = re.sub(r"<table.*?>.*?</table>", "", s, flags=re.I | re.S).strip()
            return s_wo, _coerce_table_df_to_records(df)
        df, s = _detect_markdown_table(s)
        if df is not None:
            return s, _coerce_table_df_to_records(df)
        df, s2 = _detect_csv_table(s)
        if df is not None:
            return s2, _coerce_table_df_to_records(df)
        df, s3 = _detect_tsv_table(s)
        if df is not None:
            return s3, _coerce_table_df_to_records(df)
        df, s4 = _detect_kv_grid(s)
        if df is not None:
            return s4, _coerce_table_df_to_records(df)
        return s, None

    return "", None


def add_parsed_response_columns(
    df: pd.DataFrame,
    source_col: str,                 # e.g., "modelling_team_response"
    out_text_col: str,               # e.g., "modelling_team_answer"
    out_table_col: str               # e.g., "modelling_team_table"
) -> pd.DataFrame:
    texts, tables = [], []
    for v in df[source_col].tolist():
        t, tbl = _extract_text_and_table(v)
        texts.append(t)
        tables.append(json.dumps(tbl) if tbl else "")
    df[out_text_col] = texts
    df[out_table_col] = tables
    return df


# =========================
# Word builder
# =========================

def _add_heading_run(p, text: str, size: int = 12, bold: bool = True):
    r = p.add_run(text)
    r.font.size = Pt(size)
    r.bold = bold
    return r

def _add_italic_run(p, text: str):
    r = p.add_run(text)
    r.italic = True
    return r

def _add_table_from_records(doc: Document, records_json: str):
    """
    records_json: JSON string of list[dict]; if empty/invalid -> skip
    """
    if not records_json:
        return
    try:
        rows = json.loads(records_json)
    except Exception:
        return
    if not isinstance(rows, list) or not rows:
        return
    if not isinstance(rows[0], dict):
        return

    cols = list(rows[0].keys())
    table = doc.add_table(rows=len(rows) + 1, cols=len(cols))
    table.style = "Table Grid"

    # header
    for j, c in enumerate(cols):
        cell = table.cell(0, j)
        cell.text = str(c)
        for run in cell.paragraphs[0].runs:
            run.bold = True

    # body
    for i, row in enumerate(rows):
        for j, c in enumerate(cols):
            val = row.get(c, "")
            table.cell(i + 1, j).text = "" if (pd.isna(val) if isinstance(val, float) else False) else str(val)

def build_template_with_df(
    df: pd.DataFrame,
    model: str,
    impact: str,
    scope: str = "",
    save_dir: str = "base",
    question_col: str = "IMVP Question",
    modelling_text_col: str = "modelling_team_answer",
    mrmg_text_col: str = "mrmg_answer",
    modelling_table_col: Optional[str] = "modelling_team_table",
    mrmg_table_col: Optional[str] = "mrmg_table"
) -> str:
    """
    For each row:
      - Question i: <IMVP Question> (bold)
      - Modelling Team Response (bold): text + table (if any)
      - MRMG Assessment (bold): text + table (if any)
    """
    # sanity check for required columns
    for col in [question_col]:
        if col not in df.columns:
            raise KeyError(f"Missing required column in df: '{col}'")

    os.makedirs(save_dir, exist_ok=True)
    fname = f"{model}_{impact}{('_' + scope) if scope else ''}.docx"
    out_path = os.path.join(save_dir, fname)

    doc = Document()

    # Title
    p = doc.add_paragraph()
    _add_heading_run(p, "Validation Report (Auto Generated)", size=16, bold=True)
    p.alignment = WD_ALIGN_PARAGRAPH.CENTER
    doc.add_paragraph()

    # Meta
    doc.add_paragraph(f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}")
    doc.add_paragraph()

    # Per-question blocks
    for i, row in df.iterrows():
        # QUESTION
        q = doc.add_paragraph()
        _add_heading_run(q, f"Question {i+1}: {row[question_col]}", size=12, bold=True)

        # MODELLING TEAM
        p1 = doc.add_paragraph()
        _add_heading_run(p1, "Modelling Team Response", size=11, bold=True)

        mt = str(row.get(modelling_text_col, "") or "").strip()
        if mt:
            pt = doc.add_paragraph()
            _add_italic_run(pt, mt)
        if modelling_table_col and modelling_table_col in df.columns:
            _add_table_from_records(doc, str(row.get(modelling_table_col, "") or ""))

        # MRMG
        p2 = doc.add_paragraph()
        _add_heading_run(p2, "MRMG Assessment", size=11, bold=True)

        ma = str(row.get(mrmg_text_col, "") or "").strip()
        if ma:
            pt2 = doc.add_paragraph()
            _add_italic_run(pt2, ma)
        if mrmg_table_col and mrmg_table_col in df.columns:
            _add_table_from_records(doc, str(row.get(mrmg_table_col, "") or ""))

        doc.add_paragraph()  # spacer

    doc.save(out_path)
    return out_path


# =========================
# Example usage (edit paths)
# =========================
if __name__ == "__main__":
    # 1) Load your CSV → must include at least 'IMVP Question' and 'modelling_team_response'
    #    (If your file is Excel, use pd.read_excel)
    df = pd.read_csv("mapping/Business_C.csv")

    # 2) Create the columns the builder needs from your single modelling column
    df = add_parsed_response_columns(
        df,
        source_col="modelling_team_response",   # <- your raw column
        out_text_col="modelling_team_answer",
        out_table_col="modelling_team_table"
    )

    # (Optional) If you ALSO have a single raw MRMG column, parse it too
    if "mrmg_response" in df.columns:
        df = add_parsed_response_columns(
            df,
            source_col="mrmg_response",
            out_text_col="mrmg_answer",
            out_table_col="mrmg_table"
        )
    else:
        # ensure columns exist
        if "mrmg_answer" not in df.columns:
            df["mrmg_answer"] = ""
        if "mrmg_table" not in df.columns:
            df["mrmg_table"] = ""

    # 3) Build the DOCX (saved under base/<Model>_<Impact>.docx)
    out_path = build_template_with_df(
        df,
        model="Business",
        impact="C",
        scope="",                # or "V"
        save_dir="base",
        question_col="IMVP Question",
        modelling_text_col="modelling_team_answer",
        mrmg_text_col="mrmg_answer",
        modelling_table_col="modelling_team_table",
        mrmg_table_col="mrmg_table"
    )
    print("Saved:", out_path)
