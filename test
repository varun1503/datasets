import re
import json
import unicodedata
import os
from pathlib import Path
from typing import List, Dict

import pandas as pd
from docx import Document
from docx.oxml.ns import qn
from docx.table import Table
from docx.text.paragraph import Paragraph


# ==================== NORMALIZATION ====================

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


# ==================== DOCX READING ====================

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                cells = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            cells.append(t)
                if cells:
                    lines.append(" | ".join(cells))

    return lines


# ==================== REGEX ====================

REQ_ITEMS_RX = re.compile(r"Request\s+Items", re.IGNORECASE)
RFR_RX = re.compile(r"\bRFR\s*\d+", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modell?ing Team['’]?s Response", re.IGNORECASE)
BRACKETS_RX = re.compile(r"<\s*([^>]+?)\s*>")
Q_KEY_RX = re.compile(r"Q\d+\s*:", re.IGNORECASE)


# ==================== META EXTRACTION ====================

def extract_meta_from_rfr_header(line: str):
    parts = [norm(x) for x in BRACKETS_RX.findall(line)]

    rfr_q = ""
    imvp = ""
    section = ""

    # RFR question (Q2: ...)
    for p in parts:
        if Q_KEY_RX.search(p):
            rfr_q = Q_KEY_RX.sub("", p).strip()
            break

    # IMVP question (ends with ?)
    for p in parts:
        if p.endswith("?") and not Q_KEY_RX.search(p):
            imvp = p
            break

    # Section → short label only (NOT Q, NOT long text)
    for p in parts:
        if (
            not p.endswith("?")
            and not Q_KEY_RX.search(p)
            and len(p.split()) <= 5
            and not p.lower().startswith("test")
        ):
            section = p
            break

    return rfr_q, section, imvp


def extract_test_tags(line: str) -> List[str]:
    """
    <Test S1> <Test S2> → ['tests1', 'tests2']
    """
    return [
        f"tests{m.group(1).lower()}"
        for m in re.finditer(r'<\s*Test\s*(\w+)\s*>', line, re.IGNORECASE)
    ]


# ==================== HELPERS ====================

def is_only_bullets(text: str) -> bool:
    t = text.lower()
    t = re.sub(r'\b[ivx]+\.', '', t)
    t = re.sub(r'\b[a-z]\)', '', t)
    return not t.strip()


def clean_f_key(text: str, fallback: str) -> str:
    if not text or is_only_bullets(text):
        return fallback
    return text.strip()


# ==================== CORE PARSER ====================

def parse_lines_after_request_items(lines: List[str]) -> List[Dict]:
    start = 0
    for i, t in enumerate(lines):
        if REQ_ITEMS_RX.search(t):
            start = i + 1
            break

    L = lines[start:]
    rows = []
    i = 0

    while i < len(L):
        line = L[i]

        if RFR_RX.search(line):
            rfr_q, section, imvp = extract_meta_from_rfr_header(line)
            test_tags = extract_test_tags(line)

            followups: Dict[str, str] = {}
            direct_response = ""

            current_f_key = None
            in_block = False
            buffer = []
            collecting_response = False

            i += 1

            while i < len(L) and not RFR_RX.search(L[i]):
                cur = L[i].strip()

                # -------- RESPONSE HEADER --------
                if RESP_HDR_RX.search(cur):
                    collecting_response = True
                    i += 1
                    continue

                # -------- OPEN < --------
                if cur.startswith("<"):
                    in_block = True
                    buffer = []

                    f_match = re.search(r'<\s*F(\d+)\s*:\s*(.*)', cur, re.IGNORECASE)
                    if f_match:
                        f_num = f"F{f_match.group(1)}"
                        f_text = clean_f_key(f_match.group(2).strip(), f_num)
                        current_f_key = f_text

                        rest = f_match.group(2).strip()
                        if rest:
                            buffer.append(rest)

                    i += 1
                    continue

                # -------- CLOSE > --------
                if cur.startswith(">"):
                    content = norm(" ".join(buffer))
                    in_block = False

                    if collecting_response:
                        if current_f_key:
                            followups[current_f_key] = content
                        else:
                            direct_response = content
                        collecting_response = False

                    buffer = []
                    i += 1
                    continue

                # -------- COLLECT --------
                if in_block:
                    buffer.append(cur)
                    i += 1
                    continue

                i += 1

            # -------- BUILD RFR PAYLOAD --------
            if followups:
                rfr_payload = followups
            elif direct_response:
                rfr_payload = direct_response
            else:
                i += 1
                continue

            row = {
                "IMVP Question": imvp,
                "Section": section,
                "rfr": {rfr_q: rfr_payload},
            }

            # add test flags
            for tag in test_tags:
                row[tag] = True

            rows.append(row)
            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"
    OUT_JSON = "rfr_rows.json"
    OUT_CSV = "rfr_rows.csv"

    if not Path(DOCX_PATH).exists():
        print("❌ DOCX file not found")
        return

    lines = read_docx_lines(DOCX_PATH)
    rows = parse_lines_after_request_items(lines)

    with open(OUT_JSON, "w", encoding="utf-8") as f:
        json.dump(rows, f, indent=2, ensure_ascii=False)

    df = pd.DataFrame({"finding": rows})
    df["file name"] = os.path.basename(DOCX_PATH)
    df["type"] = "rfr"
    df.to_csv(OUT_CSV, index=False)

    print("✅ Parsing completed successfully")


if __name__ == "__main__":
    main()    t = re.sub(r'\b[a-z]\)', '', t)
    return not t.strip()


def clean_f_key(text: str, fallback: str) -> str:
    if not text or is_only_bullets(text):
        return fallback
    return text.strip()


# ==================== CORE PARSER ====================

def parse_lines_after_request_items(lines: List[str]) -> List[Dict]:
    start = 0
    for i, t in enumerate(lines):
        if REQ_ITEMS_RX.search(t):
            start = i + 1
            break

    L = lines[start:]
    rows = []
    i = 0

    while i < len(L):
        line = L[i]

        if RFR_RX.search(line):
            rfr_q, section, imvp = extract_meta_from_rfr_header(line)
            test_tags = extract_test_tags(line)

            followups: Dict[str, str] = {}
            direct_response = ""

            current_f_key = None
            in_block = False
            buffer = []
            collecting_response = False

            i += 1

            while i < len(L) and not RFR_RX.search(L[i]):
                cur = L[i].strip()

                # -------- RESPONSE HEADER --------
                if RESP_HDR_RX.search(cur):
                    collecting_response = True
                    i += 1
                    continue

                # -------- OPEN < --------
                if cur.startswith("<"):
                    in_block = True
                    buffer = []

                    f_match = re.search(r'<\s*F(\d+)\s*:\s*(.*)', cur, re.IGNORECASE)
                    if f_match:
                        f_num = f"F{f_match.group(1)}"
                        f_text = clean_f_key(f_match.group(2).strip(), f_num)
                        current_f_key = f_text

                        rest = f_match.group(2).strip()
                        if rest:
                            buffer.append(rest)

                    i += 1
                    continue

                # -------- CLOSE > --------
                if cur.startswith(">"):
                    content = norm(" ".join(buffer))
                    in_block = False

                    if collecting_response:
                        if current_f_key:
                            followups[current_f_key] = content
                        else:
                            direct_response = content
                        collecting_response = False

                    buffer = []
                    i += 1
                    continue

                # -------- COLLECT --------
                if in_block:
                    buffer.append(cur)
                    i += 1
                    continue

                i += 1

            # -------- BUILD RFR PAYLOAD --------
            if followups:
                rfr_payload = followups
            elif direct_response:
                rfr_payload = direct_response
            else:
                i += 1
                continue

            row = {
                "IMVP Question": imvp,
                "Section": section,
                "rfr": {rfr_q: rfr_payload},
            }

            # add test flags
            for tag in test_tags:
                row[tag] = True

            rows.append(row)
            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"
    OUT_JSON = "rfr_rows.json"
    OUT_CSV = "rfr_rows.csv"

    if not Path(DOCX_PATH).exists():
        print("❌ DOCX file not found")
        return

    lines = read_docx_lines(DOCX_PATH)
    rows = parse_lines_after_request_items(lines)

    with open(OUT_JSON, "w", encoding="utf-8") as f:
        json.dump(rows, f, indent=2, ensure_ascii=False)

    df = pd.DataFrame({"finding": rows})
    df["file name"] = os.path.basename(DOCX_PATH)
    df["type"] = "rfr"
    df.to_csv(OUT_CSV, index=False)

    print("✅ Parsing completed successfully")


if __name__ == "__main__":
    main()
