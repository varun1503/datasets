from docx import Document
from docx.text.paragraph import Paragraph
from docx.oxml import OxmlElement
from docx.shared import Pt, RGBColor
import json, ast, re
import pandas as pd

# ---------- helpers ----------
def _to_dict_safe(x):
    if isinstance(x, dict):
        return x
    if isinstance(x, str):
        s = x.strip()
        if not s:
            return {}
        try:
            return json.loads(s)
        except Exception:
            try:
                return ast.literal_eval(s)
            except Exception:
                return {}
    return {}

def _format_run(run, bold=False):
    """Times New Roman 11, bold (opt), force BLACK color."""
    run.font.name = "Times New Roman"
    run.font.size = Pt(11)
    run.bold = bool(bold)
    # override any themed color coming from the style
    run.font.color.rgb = RGBColor(0x00, 0x00, 0x00)
    # (python-docx ignores theme_color=None sometimes, rgb wins)

def _force_paragraph_black(p: Paragraph, bold=True):
    """Ensure all runs are black (and bold if requested)."""
    if not p.runs:
        r = p.add_run("")
        _format_run(r, bold=bold)
    for r in p.runs:
        _format_run(r, bold=bold)

def _insert_paragraph_after(paragraph: Paragraph, text: str = "", bold=False) -> Paragraph:
    """Insert paragraph after `paragraph`, apply basic formatting if text provided."""
    new_p = OxmlElement("w:p")
    paragraph._p.addnext(new_p)
    new_para = Paragraph(new_p, paragraph._parent)
    if text:
        run = new_para.add_run(text)
        _format_run(run, bold=bold)
    return new_para

def _norm(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "")).strip().lower()

def _strip_numbering(s: str) -> str:
    # remove "1.", "1.1.", "2.3.4" etc at the start
    return re.sub(r'^\s*\d+(?:\.\d+)*\s*', '', s or '')

def _matches_heading_text(p: Paragraph, text: str) -> bool:
    return _norm(_strip_numbering(p.text)) == _norm(text)

def _is_heading(p: Paragraph) -> bool:
    try:
        return (p.style and p.style.name.lower().startswith("heading"))
    except Exception:
        return False

# ---------- main ----------
def replace_finding_details_section(
    doc_path: str,
    df: pd.DataFrame,
    output_path: str,
    finding_col: str = "Finding Details",
    rfr_col: str = "rfr_value",
    mrmg_col: str = "MRMG_Assessment",
    end_heading_text: str = "Validation Assessment Details",
    keep_section_text: str = "Limitations and Controls",
    toc_fallback_style: str = "Heading 2",   # used if original heading style missing
):
    """
    Replace the 'Finding Details' block with generated items, while:
      - Restoring the 'Finding Details' heading (style/numbering) so TOC picks it up
      - Forcing heading text to BLACK (overrides blue themed style)
      - PRESERVING 'Limitations and Controls' if it lies inside the window
      - KEEPING 'Validation Assessment Details' and everything after it
    """
    doc = Document(doc_path)
    paragraphs = doc.paragraphs

    # 1) Find 'Finding Details' start
    start_idx = None
    for i, p in enumerate(paragraphs):
        if "finding details" in _norm(p.text):
            start_idx = i
            break
    if start_idx is None:
        # fallback to any heading that contains 'finding'
        for i, p in enumerate(paragraphs):
            if _is_heading(p) and "finding" in _norm(p.text):
                start_idx = i
                break
    if start_idx is None:
        raise ValueError("Could not find 'Finding Details' section start.")

    # Capture original heading text/style to reinsert later (for TOC + numbering)
    orig_heading_text = paragraphs[start_idx].text or "Finding Details"
    try:
        orig_heading_style = paragraphs[start_idx].style.name
    except Exception:
        orig_heading_style = None

    # 2) Find explicit end heading (we preserve it)
    explicit_end_idx = None
    for j in range(start_idx + 1, len(paragraphs)):
        if _matches_heading_text(paragraphs[j], end_heading_text):
            explicit_end_idx = j
            break

    # end of deletion window (inclusive)
    if explicit_end_idx is not None:
        end_idx = explicit_end_idx - 1  # stop before the end heading
    else:
        # else stop before next heading after start; or to doc end
        nh = None
        for j in range(start_idx + 1, len(paragraphs)):
            if _is_heading(paragraphs[j]):
                nh = j
                break
        end_idx = (nh - 1) if nh is not None else (len(paragraphs) - 1)

    end_idx = max(end_idx, start_idx)

    # 3) Detect 'Limitations and Controls' section inside [start_idx, end_idx]
    keep_start = keep_end = None
    for k in range(start_idx, end_idx + 1):
        if _matches_heading_text(paragraphs[k], keep_section_text):
            keep_start = k
            # this keep-section ends just before the next heading (or at end_idx)
            keep_end = end_idx
            for t in range(k + 1, end_idx + 1):
                if _is_heading(paragraphs[t]):
                    keep_end = t - 1
                    break
            break

    # 4) Build deletion index set (exclude keep range if present)
    to_delete = []
    if keep_start is None:
        to_delete = list(range(start_idx, end_idx + 1))
    else:
        if keep_start > start_idx:
            to_delete.extend(range(start_idx, keep_start))
        if keep_end < end_idx:
            to_delete.extend(range(keep_end + 1, end_idx + 1))

    # 5) Choose anchor: paragraph BEFORE first deleted span (or create one at top)
    if start_idx > 0:
        anchor = paragraphs[start_idx - 1]
    else:
        first = paragraphs[0]
        new_p = OxmlElement("w:p")
        first._p.addprevious(new_p)
        anchor = Paragraph(new_p, first._parent)

    # 6) Delete from bottom to top
    for idx in sorted(to_delete, reverse=True):
        elm = paragraphs[idx]._element
        elm.getparent().remove(elm)
    paragraphs = doc.paragraphs  # refresh after deletions

    # 7) Re-insert the 'Finding Details' heading we removed and anchor to it (TOC-safe, BLACK)
    heading_p = _insert_paragraph_after(anchor, orig_heading_text, bold=True)
    try:
        if orig_heading_style and orig_heading_style.lower().startswith("heading"):
            heading_p.style = doc.styles[orig_heading_style]   # original level/numbering
        else:
            heading_p.style = doc.styles[toc_fallback_style]   # ensure TOC inclusion
    except Exception:
        heading_p.style = doc.styles.get(toc_fallback_style, heading_p.style)

    # enforce black + bold regardless of style theme color
    _force_paragraph_black(heading_p, bold=True)
    anchor = heading_p

    # 8) Insert generated content
    m_counter = 1
    for _, row in df.iterrows():
        finding_text = str(row.get(finding_col, "") or "").strip()
        rfr_dict = _to_dict_safe(row.get(rfr_col, {}))
        mrmg_text = str(row.get(mrmg_col, "") or "").strip()

        items = list(rfr_dict.items()) or [("", "")]

        for q, resp in items:
            # Finding
            p = _insert_paragraph_after(anchor, f"Finding M{m_counter}", bold=True)
            p = _insert_paragraph_after(p, finding_text)

            # Challenge
            p = _insert_paragraph_after(p, f"Challenge M{m_counter}", bold=True)
            p = _insert_paragraph_after(p, str(q).strip())

            # Modeling Team Response
            p = _insert_paragraph_after(p, f"Modeling Team Response M{m_counter}", bold=True)
            p = _insert_paragraph_after(p, str(resp).strip())

            # MRMG Assessment
            p = _insert_paragraph_after(p, f"MRMG Assessment M{m_counter}", bold=True)
            p = _insert_paragraph_after(p, mrmg_text)

            # spacer + advance
            p = _insert_paragraph_after(p, "")
            anchor = p
            m_counter += 1

    doc.save(output_path)
