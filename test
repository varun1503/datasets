import re
import json
import unicodedata
from pathlib import Path
from typing import List, Dict, Optional

from docx import Document
from docx.oxml.ns import qn
from docx.text.paragraph import Paragraph
from docx.table import Table


# ==================== NORMALIZATION ====================

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


# ==================== DOCX READING ====================

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                row_text = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            row_text.append(t)
                if row_text:
                    lines.append(" ".join(row_text))

    return lines


# ==================== HELPERS ====================

BRACKET_BLOCK_RX = re.compile(r"<\s*([^>]+?)\s*>")
TEST_RX = re.compile(r"Test\s*S(\d+)", re.IGNORECASE)
F_RX = re.compile(r"F\d+\s*:\s*(.*)", re.IGNORECASE)
Q_RX = re.compile(r"Q\d+\s*:\s*(.*)", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modell?ing Team['']?s Response", re.IGNORECASE)


# ==================== CORE PARSER ====================

def parse_doc(lines: List[str]) -> List[Dict]:
    rows = []
    i = 0

    while i < len(lines):
        line = lines[i]

        if "RFR" in line:
            blocks = [norm(b) for b in BRACKET_BLOCK_RX.findall(line)]

            rfr_q = ""
            section = ""
            imvp = ""
            test_tags = []
            f_items = {}  # Store F-item name -> response

            # ---- classify header blocks ----
            for b in blocks:
                if Q_RX.match(b):
                    rfr_q = Q_RX.match(b).group(1).strip()
                elif b.endswith("?"):
                    imvp = b
                elif TEST_RX.search(b):
                    test_tags.append(f"tests{TEST_RX.search(b).group(1)}")
                elif not section and len(b.split()) <= 5:
                    section = b

            # ---- Move past RFR header ----
            i += 1

            # ---- Look for F-items and responses ----
            current_f = None
            in_angle_block = False
            angle_buffer = []

            while i < len(lines) and "RFR" not in lines[i]:
                cur = lines[i].strip()

                # Check for F-item header
                f_match = F_RX.match(cur)
                if f_match:
                    current_f = f_match.group(1).strip("â€“- ").strip()
                    if current_f not in f_items:
                        f_items[current_f] = ""
                    i += 1
                    continue

                # Check for Modelling Team Response
                if RESP_HDR_RX.search(cur):
                    i += 1
                    continue

                # Check for opening angle bracket
                if cur == "<":
                    in_angle_block = True
                    angle_buffer = []
                    i += 1
                    continue

                # Check for closing angle bracket
                if cur == ">" or cur.startswith(">"):
                    in_angle_block = False
                    if angle_buffer:
                        content = norm(" ".join(angle_buffer))
                        if current_f:
                            # Store response for current F-item
                            f_items[current_f] = content
                            current_f = None  # Reset for next F-item
                        else:
                            # Direct response without F-item
                            f_items["response"] = content
                        angle_buffer = []
                    i += 1
                    continue

                # Collect content inside angle brackets
                if in_angle_block:
                    angle_buffer.append(cur)

                i += 1

            # Flush remaining buffer
            if angle_buffer:
                content = norm(" ".join(angle_buffer))
                if current_f:
                    f_items[current_f] = content
                elif not f_items:
                    f_items["response"] = content

            # Build the row
            rfr_payload = f_items if f_items else {"response": ""}

            row = {
                "IMVP Question": imvp,
                "Section": section,
                "rfr": {rfr_q: rfr_payload}
            }

            for t in test_tags:
                row[t] = imvp

            rows.append(row)
            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"

    if not Path(DOCX_PATH).exists():
        print(f"Error: File '{DOCX_PATH}' not found")
        return

    try:
        lines = read_docx_lines(DOCX_PATH)
        rows = parse_doc(lines)

        print(json.dumps(rows, indent=2, ensure_ascii=False))
        
        # Save to file
        with open("rfr_output.json", "w", encoding="utf-8") as f:
            json.dump(rows, f, indent=2, ensure_ascii=False)
        print(f"\nSaved {len(rows)} rows to rfr_output.json")

    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
