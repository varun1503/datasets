
import re
import json
import unicodedata
from pathlib import Path
from typing import List, Dict, Optional

from docx import Document
from docx.oxml.ns import qn
from docx.text.paragraph import Paragraph
from docx.table import Table


# ==================== NORMALIZATION ====================

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


# ==================== DOCX READING ====================

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                row_text = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            row_text.append(t)
                if row_text:
                    lines.append(" ".join(row_text))

    return lines


# ==================== HELPERS ====================

BRACKET_BLOCK_RX = re.compile(r"<\s*([^>]+?)\s*>")
TEST_RX = re.compile(r"Test\s*S(\d+)", re.IGNORECASE)
F_RX = re.compile(r"<?\s*F(\d+)\s*:?\s*(.*?)(?:–|$)", re.IGNORECASE)
Q_RX = re.compile(r"Q\d+\s*:\s*(.*)", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modell?ing Team['']?s Response", re.IGNORECASE)


# ==================== CORE PARSER ====================

def parse_doc(lines: List[str]) -> List[Dict]:
    rows = []
    i = 0

    while i < len(lines):
        line = lines[i]

        if "RFR" in line:
            blocks = [norm(b) for b in BRACKET_BLOCK_RX.findall(line)]
            
            rfr_q = ""
            section = ""
            imvp = ""
            test_tags = []
            f_items = {}  # Store F-item name -> response

            # ---- classify header blocks ----
            for b in blocks:
                if Q_RX.match(b):
                    rfr_q = Q_RX.match(b).group(1).strip()
                elif b.endswith("?"):
                    imvp = b
                elif TEST_RX.search(b):
                    test_tags.append(f"tests{TEST_RX.search(b).group(1)}")
                elif not section and len(b.split()) <= 5:
                    section = b

            # Check if F-item starts on the RFR line itself (after brackets)
            remaining_line = line
            for b in blocks:
                remaining_line = remaining_line.replace(f"<{b}>", "", 1)
            
            # If F-item detected but line doesn't end with >, keep reading until >
            f_match = F_RX.search(remaining_line)
            initial_f = None
            initial_f_content = []
            
            if f_match:
                initial_f = f_match.group(2).strip("–- ").strip()
                
                # Check if line ends with > (F-item complete on one line)
                if ">" not in remaining_line:
                    # F-item spans multiple lines, collect until >
                    temp_i = i + 1
                    while temp_i < len(lines) and ">" not in lines[temp_i]:
                        initial_f_content.append(lines[temp_i].strip())
                        temp_i += 1
                    # Include the line with > but remove the >
                    if temp_i < len(lines):
                        last_line = lines[temp_i].strip().replace(">", "").strip()
                        if last_line:
                            initial_f_content.append(last_line)
                    
                    # Store F-item with its content
                    if initial_f:
                        f_items[initial_f] = norm(" ".join(initial_f_content))
                    
                    # Move index past the F-item block
                    i = temp_i + 1
                else:
                    # F-item complete on RFR line
                    if initial_f:
                        f_items[initial_f] = ""
                    i += 1
            else:
                # No F-item on RFR line, move to next line
                i += 1

            # ---- Look for F-items and responses ----
            current_f = initial_f
            in_angle_block = False
            angle_buffer = []
            
            while i < len(lines) and "RFR" not in lines[i]:
                cur = lines[i].strip()

                # Check for closing angle bracket
                if cur == ">" or cur.startswith(">"):
                    in_angle_block = False
                    if angle_buffer:
                        content = norm(" ".join(angle_buffer))
                        if current_f:
                            # This is response for current F-item
                            f_items[current_f] = content
                            current_f = None
                        else:
                            # Direct response without F-item
                            f_items["response"] = content
                        angle_buffer = []
                    i += 1
                    continue

                # Check for opening angle bracket
                if cur == "<":
                    in_angle_block = True
                    angle_buffer = []
                    i += 1
                    continue

                # Inside angle bracket block
                if in_angle_block:
                    # Check if first line in block is a new F-item
                    if not angle_buffer:
                        f_match = F_RX.match(cur)
                        if f_match:
                            current_f = f_match.group(2).strip("–- ").strip()
                            # Read until > to get complete F-item
                            temp_content = []
                            temp_i = i + 1
                            while temp_i < len(lines) and ">" not in lines[temp_i]:
                                temp_content.append(lines[temp_i].strip())
                                temp_i += 1
                            # Include the line with >
                            if temp_i < len(lines):
                                last_line = lines[temp_i].strip().replace(">", "").strip()
                                if last_line:
                                    temp_content.append(last_line)
                            
                            if current_f:
                                f_items[current_f] = norm(" ".join(temp_content))
                            
                            # Move index past this F-item block
                            i = temp_i + 1
                            in_angle_block = False
                            continue
                    
                    # Collect line inside angle bracket (for responses)
                    angle_buffer.append(cur)
                    i += 1
                    continue

                # Check for Modelling Team Response (outside angle brackets)
                if RESP_HDR_RX.search(cur):
                    i += 1
                    continue

                i += 1

            # Flush remaining buffer
            if angle_buffer:
                content = norm(" ".join(angle_buffer))
                if current_f:
                    f_items[current_f] = content
                elif not f_items:
                    f_items["response"] = content

            # Build the row
            rfr_payload = f_items if f_items else {"response": ""}

            row = {
                "IMVP Question": imvp,
                "Section": section,
                "rfr": {rfr_q: rfr_payload}
            }

            for t in test_tags:
                row[t] = imvp

            rows.append(row)
            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"

    if not Path(DOCX_PATH).exists():
        print(f"Error: File '{DOCX_PATH}' not found")
        return

    try:
        lines = read_docx_lines(DOCX_PATH)
        rows = parse_doc(lines)

        print(json.dumps(rows, indent=2, ensure_ascii=False))

        # Save to file
        with open("rfr_output.json", "w", encoding="utf-8") as f:
            json.dump(rows, f, indent=2, ensure_ascii=False)
        print(f"\nSaved {len(rows)} rows to rfr_output.json")

    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
