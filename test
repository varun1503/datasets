import re
import json
import unicodedata
import os
import pandas as pd
from typing import List, Dict, Tuple
from docx import Document
from collections import OrderedDict
from docx.oxml.ns import qn
from docx.table import Table
from docx.text.paragraph import Paragraph


# ---------------- HELPER UTILS ----------------

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


def clean_greater_than(lines):
    return [re.sub(r'>.*$', '', s).strip() for s in lines]


# ------------ REGEX PATTERNS ------------------

REQ_ITEMS_RX = re.compile(r"^\s*Request\s+Items\s*$", re.IGNORECASE)
RFR_RX = re.compile(r"\s*\[?RFR\s*\d+\]?\s*", re.IGNORECASE)
BRACKETS_RX = re.compile(r"<\s*([^>]+?)\s*>")
Q_KEY_RX = re.compile(r"^\s*Q\d+\s*:\s*", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modeling Team['']?s Response", re.IGNORECASE)

TEST_TAG_RX = re.compile(r"^Test\s*(\w+)", re.IGNORECASE)


# ------------- DOCX LINE READING ----------------

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines: List[str] = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            t = norm(Paragraph(child, doc).text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                row_text = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            row_text.append(t)
                if row_text:
                    lines.append(" | ".join(row_text))

    return lines


# ------------------------------------------------------

def extract_meta_from_rfr_header(line: str):
    """
    Extracts: IMVP question, section, q_key, test_tag, and RFR question
    Structure: [RFR1]: <Q1: Full RFR question text here> | <Data Validation> | <IMVP question?> | <Test S1>
    """
    q_key = ""
    section = ""
    imvp = ""
    test_key = None
    rfr_question = ""

    # Extract all content within angle brackets
    parts = [norm(x) for x in BRACKETS_RX.findall(line)]
    
    if not parts:
        return q_key, section, imvp, test_key, rfr_question

    # Track indices
    q_key_idx = -1
    test_idx = -1

    # Process each part
    for idx, p in enumerate(parts):
        # Check for Q key pattern (Q1:, Q2:, etc.)
        if Q_KEY_RX.match(p):
            q_key_idx = idx
            # Extract Q key (e.g., "Q1")
            q_match = re.match(r'^\s*(Q\d+)\s*:\s*(.+)$', p, re.IGNORECASE)
            if q_match:
                q_key = q_match.group(1).strip()
                # Everything after the colon is the RFR question
                rfr_question = q_match.group(2).strip()
            continue
        
        # Check for Test tag
        test_match = TEST_TAG_RX.match(p)
        if test_match:
            tag_value = test_match.group(1).lower()
            test_key = f"tests{tag_value}"
            test_idx = idx
            continue
        
        # Check if it's a question (likely IMVP)
        if p.endswith("?"):
            imvp = p
            continue
        
        # If we've already found Q key and this isn't a question or test tag,
        # it's likely the section
        if q_key_idx >= 0 and not section and idx > q_key_idx:
            section = p

    return q_key, section, imvp, test_key, rfr_question


# ------------------------------------------------------

def parse_lines_after_request_items(lines: List[str]) -> List[Dict]:

    # Start after "Request Items"
    start = 0
    for i, t in enumerate(lines):
        if REQ_ITEMS_RX.search(t):
            start = i + 1
            break

    L = lines[start:]
    rows = []
    i = 0

    while i < len(L):
        line = L[i]

        if RFR_RX.search(line):
            # Collect the full RFR text block (may span multiple lines)
            rfr_block = [line]
            i += 1
            
            # Continue collecting lines until we hit "Modeling Team's Response"
            while i < len(L) and not RESP_HDR_RX.search(L[i]) and not RFR_RX.search(L[i]):
                rfr_block.append(L[i])
                i += 1
            
            # Join the full RFR block
            full_rfr_line = " ".join(rfr_block)
            
            # Now extract metadata from the full line
            q_key, section, imvp_q, test_tag, _ = extract_meta_from_rfr_header(full_rfr_line)
            
            # Extract the RFR question: text after Q#: and before the next | or >
            rfr_question = ""
            # Find the Q#: part
            q_match = re.search(r'<\s*Q\d+\s*:\s*([^<>|]+?)(?:\s*[|>]|\s*<)', full_rfr_line, re.IGNORECASE | re.DOTALL)
            if q_match:
                rfr_question = norm(q_match.group(1))
            
            responses = []

            # Collect responses
            while i < len(L) and not RFR_RX.search(L[i]):
                cur = L[i]

                # Modeling Team Response block
                if RESP_HDR_RX.search(cur):
                    i += 1
                    block = []

                    while (
                        i < len(L)
                        and not RESP_HDR_RX.search(L[i])
                        and not RFR_RX.search(L[i])
                    ):
                        block.append(L[i])
                        i += 1

                    resp = norm(" ".join(block))
                    if resp:
                        responses.append(resp)
                    continue

                i += 1

            responses = clean_greater_than(responses)
            full_resp = " ".join(responses).strip()

            # Skip if no IMVP question
            if not imvp_q:
                continue

            # Build row - RFR question as key, response as value
            row = {
                test_tag: imvp_q,
                "section": section,
                "rfr": {rfr_question: full_resp} if rfr_question else {}
            }

            rows.append(row)
            continue

        i += 1

    return rows


# ------------------------------------------------------

def convert_csv(rows, path):
    file_name = os.path.basename(path)
    df = pd.DataFrame(rows)
    df["file name"] = file_name
    df["type"] = "rfr"
    return df


# ------------------------------------------------------

if __name__ == "__main__":
    DOCX_PATH = "FinalRFRorignal.docx"
    OUT_PATH = "rfr_rows.json"

    lines = read_docx_lines(DOCX_PATH)
    
    # Debug: print first few lines to see structure
    print("First 10 lines:")
    for i, line in enumerate(lines[:10]):
        print(f"{i}: {line[:100]}...")
    
    rows = parse_lines_after_request_items(lines)
    
    # Debug: print first row
    if rows:
        print("\nFirst row:")
        print(json.dumps(rows[0], indent=2, ensure_ascii=False))
    
    df = convert_csv(rows, DOCX_PATH)

    print(f"\nDataFrame shape: {df.shape}")
    print(df.head())

    with open(OUT_PATH, "w", encoding="utf-8") as f:
        for r in rows:
            f.write(json.dumps(r, ensure_ascii=False) + "\n")

    print(f"\nWrote {len(rows)} row(s) to {OUT_PATH}")
