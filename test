import ast

insert_chunk2 = []

# Build a map from parent_node to its corresponding quadruples (merged from final_chunk)
parent_to_quads = {}
for doc in final_chunk:
    parent = doc[0].metadata.get("parent_node")
    if parent:
        parent_to_quads.setdefault(parent, []).extend(doc[0].metadata.get("quadruples", []))

# Build a map from doc_id to index for quick lookup
doc_id_to_index = {doc[0].metadata["doc_id"]: idx for idx, doc in enumerate(final_chunk)}

for i, parent_doc in enumerate(parent_chunk):
    parent_node = parent_doc[0]
    child_list = parent_node.metadata.get('child_nodes', [])

    # Gather child quadruples for all children
    parent_q = {child: parent_to_quads.get(child, []) for child in child_list}

    input_node = {"input_quadruples_dict": parent_q}
    pruned_prompt = prompts().pruning_prompt()
    pruned_kg = invoke().model_call("3", pruned_prompt, input_node)

    cc = pruned_kg.content.strip().removeprefix("python").removesuffix(".")
    print(cc)

    v = ast.literal_eval(cc)
    parent_node.metadata["qudipals"] = v

    # Prepare common metadata excluding 'qudipals'
    base_metadata = dict(list(parent_node.metadata.items())[:-1])
    base_metadata["content"] = parent_node.page_content

    for key, value_list in v.items():
        for quadruple in value_list:
            idx = doc_id_to_index.get(key)
            if idx is not None:
                insert_chunk2.append({
                    "metadata": base_metadata.copy(),
                    "quadruples": quadruple
                })
