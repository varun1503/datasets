import os, json, ast, re
from typing import Any, List, Dict, Optional, Tuple
import pandas as pd
from docx import Document
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH


# ---------- small helpers ----------

def _add_heading_run(p, text: str, size: int = 12, bold: bool = True):
    r = p.add_run(text)
    r.font.size = Pt(size)
    r.bold = bold
    return r

def _add_italic_paragraph(doc: Document, text: str):
    p = doc.add_paragraph()
    r = p.add_run(text)
    r.italic = True

def _safe_set_style(paragraph, style_name: str):
    """Try to apply paragraph style by name; fallback silently."""
    try:
        paragraph.style = style_name
    except Exception:
        # style might not exist in the document (custom styles from source);
        # fallback to Normal
        try:
            paragraph.style = 'Normal'
        except Exception:
            pass

def _df_from_list_list(rows: List[List[Any]]) -> pd.DataFrame:
    if not rows:
        return pd.DataFrame()
    header = rows[0]
    data = rows[1:] if len(rows) > 1 else []
    if not all(isinstance(h, str) for h in header):
        header = [f"Col{j+1}" for j in range(len(header))]
    # pad ragged rows
    maxlen = max((len(r) for r in [header] + data), default=0)
    header = header + [f"Col{j+1}" for j in range(len(header), maxlen)]
    data2 = [list(r) + [""]*(maxlen-len(r)) for r in data]
    return pd.DataFrame(data2, columns=header)

def _add_table_from_records(doc: Document, rows: List[Dict[str, Any]]):
    """rows: list of dicts -> render as Word table"""
    if not rows:
        return
    cols = list(rows[0].keys())
    table = doc.add_table(rows=len(rows) + 1, cols=len(cols))
    table.style = "Table Grid"

    # header
    for j, c in enumerate(cols):
        cell = table.cell(0, j)
        cell.text = str(c)
        for run in cell.paragraphs[0].runs:
            run.bold = True

    # body
    for i, row in enumerate(rows):
        for j, c in enumerate(cols):
            val = row.get(c, "")
            table.cell(i + 1, j).text = "" if (pd.isna(val) if isinstance(val, float) else False) else str(val)

def _parse_tables_field(tbl_field: Any) -> List[List[Dict[str, Any]]]:
    """
    Your sample 'table' is a STRING that encodes a LIST of TABLES.
    Each TABLE can be:
      - list[dict, dict, ...]                     -> good
      - list[list-of-dicts] (already "rows")      -> good
    Returns: list_of_tables, where each table is rows(list[dict])
    """
    if not tbl_field or tbl_field == "None":
        return []

    # Step 1: if string, parse JSON / python literal
    if isinstance(tbl_field, str):
        s = tbl_field.strip()
        if not s:
            return []
        parsed = None
        for loader in (json.loads, ast.literal_eval):
            try:
                parsed = loader(s)
                break
            except Exception:
                pass
        if parsed is None:
            return []
        tbl_field = parsed  # now python objects

    # Now tbl_field should be list[...] in your case
    tables_out: List[List[Dict[str, Any]]] = []

    if isinstance(tbl_field, list):
        for sub in tbl_field:
            # Case A: sub is list[dict] -> already rows
            if isinstance(sub, list) and sub and isinstance(sub[0], dict):
                tables_out.append(sub)
            # Case B: sub is dict -> wrap single-row table
            elif isinstance(sub, dict):
                tables_out.append([sub])
            # Case C: sub is list of lists (2D) -> first row headers
            elif isinstance(sub, list) and sub and isinstance(sub[0], (list, tuple)):
                df = _df_from_list_list([list(r) for r in sub])
                tables_out.append(json.loads(df.to_json(orient="records")))
            # else: ignore
    elif isinstance(tbl_field, dict):
        tables_out.append([tbl_field])

    return tables_out

def _split_content_to_paragraphs(content: str) -> List[str]:
    """
    Split markdown-ish content into paragraphs by blank lines,
    but keep bullet lines grouped if possible.
    """
    if not content:
        return []
    # normalize line endings
    text = content.replace("\r\n", "\n").replace("\r", "\n").strip()
    # split on blank lines
    paras = re.split(r"\n\s*\n", text)
    return [p.strip() for p in paras if p.strip()]


# ---------- main builder ----------

def build_template_from_retrieved(
    df: pd.DataFrame,
    model: str,
    impact: str,
    scope: str = "",
    save_dir: str = "base",
    retrieved_col: str = "retrieved_results_output",
    question_col: str = "IMVP Question",
) -> str:
    """
    Build a DOCX from a DF where each row's `retrieved_col` is a JSON list of dicts:
      { "heading": ..., "subheading": ..., "content": ..., "style": "['Normal', 'Heading 2', ...']", "table": "<stringified list of tables>" }

    For each row:
      - "Question i: <IMVP Question>" (bold)
      - "Modelling Team Response" (bold)
      - For each item within retrieved_results_output:
          * print heading/subheading if present
          * split content into paragraphs and apply per-paragraph style from 'style' list when available
          * render any tables as real Word tables
    """
    # sanity checks
    for c in [retrieved_col, question_col]:
        if c not in df.columns:
            raise KeyError(f"Missing column '{c}' in DataFrame.")

    os.makedirs(save_dir, exist_ok=True)
    fname = f"{model}_{impact}{('_' + scope) if scope else ''}.docx"
    out_path = os.path.join(save_dir, fname)

    doc = Document()

    # Title
    p = doc.add_paragraph()
    _add_heading_run(p, "Validation Report (Auto Generated)", size=16, bold=True)
    p.alignment = WD_ALIGN_PARAGRAPH.CENTER
    doc.add_paragraph()

    # Meta
    doc.add_paragraph(f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}")
    doc.add_paragraph()

    # Iterate questions
    for i, row in df.iterrows():
        # --- Question header ---
        q = doc.add_paragraph()
        _add_heading_run(q, f"Question {i+1}: {row[question_col]}", size=12, bold=True)

        # --- Section title for modelling team block ---
        pmt = doc.add_paragraph()
        _add_heading_run(pmt, "Modelling Team Response", size=11, bold=True)

        # Parse retrieved payload
        payload = row[retrieved_col]
        # Convert string -> python list if needed
        if isinstance(payload, str):
            parsed = None
            for loader in (json.loads, ast.literal_eval):
                try:
                    parsed = loader(payload)
                    break
                except Exception:
                    pass
            if parsed is None:
                # If plain text, just write once
                _add_italic_paragraph(doc, payload.strip())
                doc.add_paragraph()
                continue
            payload = parsed

        if not isinstance(payload, list):
            # unknown format, just print as text
            _add_italic_paragraph(doc, str(payload))
            doc.add_paragraph()
            continue

        # For each retrieved item (usually 1..N per row)
        for item in payload:
            if not isinstance(item, dict):
                continue

            heading = str(item.get("heading", "") or "").strip()
            subhead = str(item.get("subheading", "") or "").strip()
            content = str(item.get("content", "") or "").strip()

            # ---- headings/subheadings if present
            if heading:
                ph = doc.add_paragraph()
                # try to use a heading style from the name if available
                # e.g., if heading string itself looks like "7. Testing the Model..." we'll just bold it.
                _add_heading_run(ph, heading, size=11, bold=True)

            if subhead and subhead.lower() not in {"none", "null"}:
                psh = doc.add_paragraph()
                _add_heading_run(psh, subhead, size=11, bold=True)

            # ---- styles array for the content paragraphs
            styles_raw = item.get("style", "")
            styles_list: List[str] = []
            if styles_raw:
                try:
                    # your style comes like "['Heading 2','Normal',...]" -> parse it
                    styles_list = ast.literal_eval(styles_raw) if isinstance(styles_raw, str) else styles_raw
                    if not isinstance(styles_list, list):
                        styles_list = []
                except Exception:
                    styles_list = []

            # ---- write content paragraphs with per-paragraph style where we can
            if content:
                paragraphs = _split_content_to_paragraphs(content)
                for idx, para in enumerate(paragraphs):
                    ppara = doc.add_paragraph()
                    # apply style if provided
                    if idx < len(styles_list) and isinstance(styles_list[idx], str):
                        _safe_set_style(ppara, styles_list[idx])
                    else:
                        # heuristic: bullet lines -> List Paragraph
                        if para.strip().startswith(("-", "*")):
                            _safe_set_style(ppara, "List Paragraph")
                        else:
                            _safe_set_style(ppara, "Normal")
                    ppara.add_run(para)

            # ---- render tables (can be multiple)
            tables = _parse_tables_field(item.get("table"))
            for trows in tables:
                if trows:
                    _add_table_from_records(doc, trows)

        # spacer between questions
        doc.add_paragraph()

    doc.save(out_path)
    return out_path
