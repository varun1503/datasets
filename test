import requests
import json

def call_api(url: str, payload: dict = None, headers: dict = None, method: str = "POST"):
    """
    Call an API endpoint.

    Args:
        url (str): The API endpoint URL
        payload (dict, optional): The request body (for POST/PUT). Defaults to None.
        headers (dict, optional): HTTP headers. Defaults to {"Content-Type": "application/json"}.
        method (str, optional): HTTP method (GET, POST, PUT, DELETE). Defaults to "POST".

    Returns:
        dict: JSON response from the API or error message
    """
    if headers is None:
        headers = {"Content-Type": "application/json"}

    try:
        if method.upper() == "GET":
            response = requests.get(url, params=payload, headers=headers, timeout=30)
        elif method.upper() == "POST":
            response = requests.post(url, json=payload, headers=headers, timeout=30)
        elif method.upper() == "PUT":
            response = requests.put(url, json=payload, headers=headers, timeout=30)
        elif method.upper() == "DELETE":
            response = requests.delete(url, headers=headers, timeout=30)
        else:
            return {"error": f"Unsupported method: {method}"}

        response.raise_for_status()
        return response.json()

    except requests.exceptions.RequestException as e:
        return {"error": str(e)}


# Example usage:
if __name__ == "__main__":
    api_url = "https://httpbin.org/post"  # test API endpoint
    data = {"message": "Hello from Python!"}
    result = call_api(api_url, payload=data, method="POST")
    print(json.dumps(result, indent=2))                    style.append(item.get("style"))

            # --- Paragraph ---
            elif item_type == "paragraph":
                raw_text = item.get("text", "")
                text = self.clean_paragraph_text(raw_text)
                if text:
                    paragraph_parts.append(text)     # ← no "+= ' '"
                    last_was_heading = False

                if item.get("style_extract"):
                    style_extracted.extend(item.get("style_extract") or [])
                if item.get("caption") is not None:
                    current_caption.append(item.get("caption"))
                if item.get("style"):
                    style.append(item.get("style"))

            # --- Table ---
            elif item_type == "table":
                if last_was_heading and tmrc_checklist is None:
                    if item.get("style"):
                        style.extend(item.get("style") or [])
                    tmrc_checklist = item.get("data", [])
                    last_was_heading = False
                else:
                    current_tables.append(item.get("data", []))
                    if item.get("style"):
                        style.append(item.get("style"))

            # --- Image ---
            elif item_type == "image":
                if item.get("style"):
                    style.extend(item.get("style") or [])
                context = (item.get("image_context") or "").strip()
                if context:
                    current_base64.append(context)
                last_was_heading = False

        flush_chunk()
        return preprocess_chunk

    def chunk_document(self, preprocess_chunk):
        final_chunk = []

        for i in range(1, len(preprocess_chunk)):
            chunk = preprocess_chunk[i]
            if not isinstance(chunk, dict):
                continue

            # ensure metadata exists
            metadata = chunk.get("metadata", {})
            chunk["metadata"] = metadata

            metadata.update({
                "heading": chunk.get("heading"),
                "subheading": chunk.get("subheading"),
                "table": chunk.get("table"),
                "image_context": chunk.get("image_context"),
                "tmrc_checklist": chunk.get("tmrc_checklist"),
                "source": chunk.get("Source"),
                "section": chunk.get("section"),
                "subsection": chunk.get("subsection"),
                "caption": chunk.get("caption"),
                "style": chunk.get("style"),
                "style_extracted": chunk.get("style_extracted"),
            })

            text = chunk.get("paragraph") or "None"
            doc = Document(page_content=text, metadata=metadata)
            final_chunk.append(doc)

        dict_chunk = {preprocess_chunk[0]["Source"]: final_chunk} if preprocess_chunk else {}
        return dict_chunk

import json

def save_dict_chunk(dict_chunk, file_path="dict_chunk_output.json"):
    try:
        with open(file_path, "w", encoding="utf-8") as f:
            json.dump(dict_chunk, f, indent=2, ensure_ascii=False)
        print(f"✅ Dict chunk saved to {file_path}")
    except Exception as e:
        print(f"❌ Failed to save: {e}")
