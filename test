# common/pg_store.py
import os
import json
import asyncpg
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise ValueError("DATABASE_URL must be set in .env")

DEFAULT_LAST_N = int(os.getenv("LAST_N_HISTORY", "50"))

class PostgresStore:
    def __init__(self, dsn: str = None, min_size: int = 1, max_size: int = 10):
        self.dsn = dsn or DATABASE_URL
        self.pool: Optional[asyncpg.Pool] = None
        self.min_size = min_size
        self.max_size = max_size

    async def init(self):
        if self.pool is None:
            self.pool = await asyncpg.create_pool(dsn=self.dsn, min_size=self.min_size, max_size=self.max_size)

    async def close(self):
        if self.pool:
            await self.pool.close()
            self.pool = None

    # -------------------------
    # Conversation (transcript)
    # -------------------------
    async def save_message(self,
                           app_name: str,
                           agent_name: Optional[str],
                           user_id: str,
                           session_id: str,
                           role: str,
                           content: Dict[str, Any]):
        """
        content: JSON-serializable dict (we store ADK parts JSON here)
        """
        await self.init()
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO adk_conversations (app_name, agent_name, user_id, session_id, role, content)
                VALUES ($1, $2, $3, $4, $5, $6::jsonb)
                """,
                app_name, agent_name, user_id, session_id, role, json.dumps(content)
            )

    async def get_history(self, app_name: str, user_id: str, session_id: str, last_n: Optional[int] = None) -> List[Dict[str, Any]]:
        """
        Return messages in ascending order (oldest first).
        If last_n is provided, returns the last N messages (still ordered oldest->newest).
        Each item: {"role": ..., "content": {...}}
        """
        await self.init()
        async with self.pool.acquire() as conn:
            if last_n:
                rows = await conn.fetch(
                    """
                    SELECT role, content, created_at
                    FROM adk_conversations
                    WHERE app_name=$1 AND user_id=$2 AND session_id=$3
                    ORDER BY created_at DESC
                    LIMIT $4
                    """,
                    app_name, user_id, session_id, last_n
                )
                rows = list(reversed(rows))
            else:
                rows = await conn.fetch(
                    """
                    SELECT role, content, created_at
                    FROM adk_conversations
                    WHERE app_name=$1 AND user_id=$2 AND session_id=$3
                    ORDER BY created_at ASC
                    """,
                    app_name, user_id, session_id
                )
        out = []
        for r in rows:
            content = r["content"]
            if isinstance(content, str):
                try:
                    content = json.loads(content)
                except Exception:
                    content = {"parts": [{"text": content}]}
            out.append({"role": r["role"], "content": content})
        return out

    # -------------------------
    # Key-value facts (structured memory)
    # -------------------------
    async def upsert_fact(self, app_name: str, user_id: str, session_id: Optional[str], key: str, value: Dict[str, Any]):
        """
        Upsert a structured fact (JSON). session_id may be NULL for user-scoped facts.
        """
        await self.init()
        async with self.pool.acquire() as conn:
            await conn.execute(
                """
                INSERT INTO adk_facts (app_name, user_id, session_id, key, value)
                VALUES ($1, $2, $3, $4, $5::jsonb)
                ON CONFLICT (app_name, user_id, session_id, key)
                DO UPDATE SET value = $5::jsonb, updated_at = now()
                """,
                app_name, user_id, session_id, key, json.dumps(value)
            )

    async def get_fact(self, app_name: str, user_id: str, session_id: Optional[str], key: str) -> Optional[Dict[str, Any]]:
        await self.init()
        async with self.pool.acquire() as conn:
            row = await conn.fetchrow(
                """
                SELECT value FROM adk_facts
                WHERE app_name=$1 AND user_id=$2 AND session_id=$3 AND key=$4
                """,
                app_name, user_id, session_id, key
            )
            if row:
                v = row["value"]
                if isinstance(v, str):
                    try:
                        return json.loads(v)
                    except:
                        return {"value": v}
                return v
            return None

    async def list_facts(self, app_name: str, user_id: str, session_id: Optional[str] = None):
        await self.init()
        async with self.pool.acquire() as conn:
            rows = await conn.fetch(
                """
                SELECT key, value, updated_at FROM adk_facts
                WHERE app_name=$1 AND user_id=$2 AND session_id=$3
                ORDER BY updated_at ASC
                """,
                app_name, user_id, session_id
            )
        return [{"key": r["key"], "value": r["value"], "updated_at": r["updated_at"]} for r in rows]
