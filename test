from docx.shared import Pt, Inches, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.table import WD_TABLE_ALIGNMENT, WD_ALIGN_VERTICAL
from docx.oxml import OxmlElement
from docx.oxml.ns import qn

EMU_PER_INCH = 914400

def _emu_to_inches(v):  # EMU -> inches
    return float(v) / EMU_PER_INCH

def _estimate_col_weight(series):
    """Heuristic weight = max string length in the column."""
    # handle NaNs/None robustly
    lengths = (series.fillna("").astype(str).map(len)).tolist()
    return max(lengths) if lengths else 1

def _format_header_cell(cell):
    cell.vertical_alignment = WD_ALIGN_VERTICAL.CENTER
    for p in cell.paragraphs:
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        for r in p.runs:
            r.font.bold = True
            r.font.color.rgb = RGBColor(255, 255, 255)
            r.font.size = Pt(11)

def _set_cell_bg(cell, hex_color: str = "000000"):
    tc_pr = cell._tc.get_or_add_tcPr()
    shd = tc_pr.find(qn('w:shd'))
    if shd is None:
        shd = OxmlElement('w:shd')
        tc_pr.append(shd)
    shd.set(qn('w:fill'), hex_color)
    shd.set(qn('w:val'), 'clear')
    shd.set(qn('w:color'), 'auto')

def _force_table_borders(table, color="000000", size=8):
    tbl = table._tbl
    tblPr = tbl.tblPr or OxmlElement('w:tblPr')
    if tbl.tblPr is None:
        tbl.append(tblPr)
    borders = tblPr.find(qn('w:tblBorders'))
    if borders is None:
        borders = OxmlElement('w:tblBorders')
        tblPr.append(borders)
    for edge in ['top','left','bottom','right','insideH','insideV']:
        el = borders.find(qn(f'w:{edge}'))
        if el is None:
            el = OxmlElement(f'w:{edge}')
            borders.append(el)
        el.set(qn('w:val'), 'single')
        el.set(qn('w:sz'), str(size))
        el.set(qn('w:space'), '0')
        el.set(qn('w:color'), color)

def _add_findings_table_dynamic(doc, findings_df):
    if findings_df is None or len(findings_df) == 0:
        return

    # Normalize / pick columns
    colmap = {c.lower().strip(): c for c in findings_df.columns}
    def pick(*aliases):
        for a in aliases:
            if a.lower() in colmap:
                return colmap[a.lower()]
        return None

    c_q = pick("IMVP question","imvp_question","imvp q","imvp")
    c_ic = pick("Finding Impact Category","impact category","finding impact category","impact")
    c_fd = pick("Finding Details","finding detail","details","finding details")
    c_fs = pick("Finding Status","status","finding status")
    cols = [c_q, c_ic, c_fd, c_fs]
    headers = ["IMVP Question","Finding Impact Category","Finding Details","Finding Status"]
    if not all(cols):
        # fall back to your old static function or show a note
        p = doc.add_paragraph()
        r = p.add_run("Findings (required columns missing)")
        r.bold = True
        return

    # Section + caption
    sec = doc.add_paragraph()
    sr = sec.add_run("Findings")
    sr.bold = True
    sr.font.size = Pt(12)

    cap = doc.add_paragraph("Summary of Findings")
    cap.alignment = WD_ALIGN_PARAGRAPH.CENTER
    cap.runs[0].bold = True
    cap.runs[0].font.size = Pt(12)

    # Build table
    table = doc.add_table(rows=1, cols=4)
    table.alignment = WD_TABLE_ALIGNMENT.CENTER
    table.autofit = False  # we'll set widths manually
    _force_table_borders(table, "000000")

    # Header row
    hdr = table.rows[0].cells
    for i, h in enumerate(headers):
        hdr[i].text = h
        _set_cell_bg(hdr[i], "000000")
        _format_header_cell(hdr[i])

    # Compute dynamic widths
    # Page usable width = page_width - left_margin - right_margin (inches)
    secn = doc.sections[-1]
    usable_in = _emu_to_inches(secn.page_width - secn.left_margin - secn.right_margin)

    # Heuristic weights from content
    weights = [
        _estimate_col_weight(findings_df[cols[0]]),
        _estimate_col_weight(findings_df[cols[1]]),
        _estimate_col_weight(findings_df[cols[2]]),
        _estimate_col_weight(findings_df[cols[3]]),
    ]
    if sum(weights) == 0:
        weights = [1,1,2,1]  # reasonable default bias to Details

    # Min/Max guards (tweak as you like)
    min_w = [1.2, 1.4, 2.4, 1.2]   # inches
    max_w = [2.0, 2.4, 5.0, 2.0]

    # First pass proportional widths
    raw = [w / sum(weights) * usable_in for w in weights]

    # Clamp to min/max, then renormalize if needed
    clamped = [max(min_w[i], min(max_w[i], raw[i])) for i in range(4)]
    total = sum(clamped)
    # If total != usable, scale proportionally but keep mins respected
    if total != 0 and abs(total - usable_in) > 1e-3:
        scale = usable_in / total
        clamped = [max(min_w[i], min(max_w[i], clamped[i] * scale)) for i in range(4)]

    # Apply widths
    for i, w_in in enumerate(clamped):
        for cell in table.columns[i].cells:
            cell.width = Inches(w_in)

    # Data rows
    for _, r in findings_df.iterrows():
        row_cells = table.add_row().cells
        row_cells[0].text = str(r.get(cols[0], "")).strip()
        row_cells[1].text = str(r.get(cols[1], "")).strip()
        row_cells[2].text = str(r.get(cols[2], "")).strip()
        row_cells[3].text = str(r.get(cols[3], "")).strip()
        for c in row_cells:
            c.vertical_alignment = WD_ALIGN_VERTICAL.CENTER
            for p in c.paragraphs:
                p.alignment = WD_ALIGN_PARAGRAPH.LEFT
                for run in p.runs:
                    run.font.size = Pt(10)

    doc.add_paragraph()  # spacer
