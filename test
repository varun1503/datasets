Below is expanded, PPT-ready content with deep-dive explanations for each slide, focusing on:

✔ Concept
✔ Implementation in ADK
✔ Classes / methods
✔ Why it's needed
✔ How it works internally

This is the detailed version suitable for a 20–30 min technical presentation.


---

⭐ SECTION 1 — FOUNDATIONAL CONCEPTS

Slide 1 — Title

Conversational Context in ADK: Session, State & Memory
Creating intelligent, persistent, context-aware agents.


---

⭐ Slide 2 — Why Context Matters

Agents must:

Understand what was said earlier

Track task progress

Remember user preferences

Avoid repeating questions

Maintain continuity across multiple sessions


Problem in existing frameworks (LangChain, LamaIndex):

No built-in persistent conversation model

Developers must manually code memory/state

No event log

No session lifecycle management


ADK solves this by implementing a structured runtime:

Session → conversation timeline

State → per-session, per-user, per-app, per-invocation storage

Memory → cross-session knowledge bank



---

⭐ SECTION 2 — SESSION

Slide 3 — What is a Session? (Concept)

A Session represents a single conversation thread between a user and your agent.

Think of it as:

Chat thread

Container of all history

Execution context for tasks


A Session stores:

1. Events — messages & tool calls


2. State — temporary data


3. Metadata — app_name, user_id, last updated time




---

⭐ Slide 4 — Session (Implementation in ADK)

ADK provides a dedicated class:

google.adk.sessions.Session

Created & managed by:

SessionService

ADK stores:

session.id → unique ID

session.app_name → which app this session belongs to

session.user_id → user identity

session.events → full chronological history

session.state → scratchpad for dynamic values

session.last_update_time → activity timestamp


Internally:

Every agent response becomes an Event

Every tool execution becomes an Event

State changes are stored via EventActions.state_delta



---

⭐ Slide 5 — SessionService (Implementation)

Responsible for entire lifecycle.

Key responsibilities:

Create a new session

Retrieve existing session

Append events

Merge state updates

Persist data based on backend

Delete session


Implementations:

Type	Description	Persistence

InMemorySessionService	Session stored in RAM	❌ No persistence
DatabaseSessionService	RDBMS (SQLite, Postgres)	✔ Persistent
VertexAiSessionService	Managed by Vertex AI	✔ Persistent & scalable



---

⭐ Slide 6 — SessionService (Important Methods)

Python equivalents:

create_session(app_name, user_id, session_id, state)
get_session(app_name, user_id, session_id)
append_event(session, event)
delete_session(app_name, user_id, session_id)
list_sessions(app_name, user_id)

append_event() is the heart of ADK:

Writes event to the event log

Applies state_delta to session.state

Updates last_update_time

Ensures consistency & thread-safety

Ensures prefix-scoped persistence



---

⭐ Slide 7 — Session Example (Code)

session_service = InMemorySessionService()

session = await session_service.create_session(
    app_name="travel_bot",
    user_id="user123",
    session_id="s1",
    state={"initial": "hello"}
)

print(session.events)  # []
print(session.state)   # {"initial": "hello"}


---

⭐ SECTION 3 — STATE

Slide 8 — What is State? (Concept)

State is a structured key-value store within a session.

Used for:

Task progress (e.g., booking_step = "payment_pending")

User-specific preferences (e.g., user:language = "English")

Temporary flags (e.g., temp:raw_api_response)

Multi-turn agent reasoning


Why needed?

LLMs forget context unless structured memory exists.

ADK adds a reliable, deterministic storage layer.


---

⭐ Slide 9 — Types of State in ADK (Prefix Scopes)

Prefix	Scope	Persistence	Use Case

"" (no prefix)	session	Depends on service	Task flow, temporary logic
user:	across sessions for same user	Persistent	Preferences, profile
app:	global to entire application	Persistent	Global configs
temp:	within single invocation	Not persistent	Intermediate data


Example:

session.state["user:theme"]="dark"
session.state["booking_step"]="CONFIRMING"
session.state["temp:validation"]="ok"


---

⭐ Slide 10 — State (Implementation Rules)

✔ Correct ways to modify state:

1. Agent output_key


2. EventActions.state_delta


3. CallbackContext.state


4. ToolContext.state



❌ Wrong way (NOT allowed):

session.state["key"] = value  # WRONG (no event generated)

Why this restriction?

Because state updates MUST:

Be recorded as events

Update last_update_time

Be persisted correctly

Maintain reliability and concurrency safety



---

⭐ Slide 11 — State Management Example

1) Using output_key

agent = LlmAgent(
    model="gemini-2.0-flash",
    name="Greeter",
    instruction="Say hello",
    output_key="last_greeting"
)

Stores in:

session.state["last_greeting"] = agent_response

2) Using EventActions

EventActions(state_delta={
    "task_status": "active",
    "user:login_count": 1
})

3) Using CallbackContext

def after_agent(context):
    context.state["temp:node"]="summary"


---

⭐ SECTION 4 — MEMORY

Slide 12 — What is Memory? (Concept)

Memory stores long-term information, beyond the current session.

Used for:

Cross-session personalisation

Remembering facts from past conversations

Semantic recall (e.g., “What is my favourite project?”)


Why needed?

Session = short-term
Memory = long-term knowledge base


---

⭐ Slide 13 — Memory Implementations

1. InMemoryMemoryService

Fast

Simple keyword search

Stored in RAM

Good for debugging


2. VertexAiMemoryBankService

Full semantic memory

Extracts meaningful memories from sessions

Stores in Vertex AI Memory Bank

Fully managed, scalable

Persistent forever

Supports rich search



---

⭐ Slide 14 — MemoryService Important Methods

add_session_to_memory(session)
search_memory(app_name, user_id, query)

Memory ingestion:

LLM extracts important facts from Event history

Converts them into Memory records

Semantic vector-based indexing



---

⭐ Slide 15 — Example: Store & Search Memory

memory_service = InMemoryMemoryService()

await memory_service.add_session_to_memory(session)

results = await memory_service.search_memory(
    app_name="travel_bot",
    user_id="user123",
    query="favorite project"
)


---

⭐ SECTION 5 — FULL EXAMPLE FLOW

Slide 16 — Full Flow: Session → State → Memory

User: “My favorite project is Alpha”

↓ SessionService.create_session

Agent responds  
↓ Runner.create_event  
↓ EventActions.state_delta  
State updated

↓ append_event  
Event stored  
State persisted

↓ add_session_to_memory  
Memory Bank stores "favorite project = Alpha"

Next day…

User: “What is my favorite project?”

↓ load_memory Tool  
↓ semantic search  
Agent retrieves answer from memory


---

⭐ SECTION 6 — ADK vs LANGCHAIN

Slide 17 — Why ADK > LangChain (Technical)

1. Native Support for Sessions

Feature	ADK	LangChain

Session model	✓ native	✗ needs custom code
Unified event log	✓	✗
Multi-turn consistency	✓	partial



---

⭐ Slide 18 — State Superiority

ADK State:

Prefix-scoped

Auto-persisted

Thread-safe

Connected to events

Integrated with tools and agents


LangChain:

Uses Python variables or custom memory objects

No persistence

No event log

No user/app scoping



---

⭐ Slide 19 — Memory: ADK Advantage

ADK Memory

LLM-generated memories

Highly-relevant extraction

Semantic search via Vertex AI Memory Bank

Automatically ingest sessions


LangChain “memory”

Only keeps recent chat history

Not cross-session

No semantic memory

No managed storage



---

⭐ Slide 20 — Multi-Agent Advantage

ADK:

temporary state shared across agents

event lifecycle integrated

deterministic behaviour


LangChain:

no universal state model

agents do not share memory

unpredictable cross-tool execution



---

⭐ Slide 21 — Summary

Session → complete conversation log

State → dynamic knowledge store with scoped prefixes

Memory → persistent long-term memory

ADK provides structured, deterministic, scalable conversational intelligence

Far superior to LangChain for:

multi-turn conversations

long-term memory

user/app-level personalization

production systems




---

⭐ Slide 22 — Want the PPT File?

I can generate:

✔ PowerPoint (.pptx)
✔ With diagrams
✔ With icons & visuals
✔ With speaker notes
✔ With animations

Just say: “Generate PPT” or “Give me the PPT file”.
