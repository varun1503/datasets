
Here's the complete code with all the MCP changes:

## 1. MCP Server (`mcp_server.py`)

```python
# mcp_server.py
import asyncio
from datetime import datetime
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

# Initialize MCP server
app = Server("greeting-tools-server")

@app.list_tools()
async def list_tools() -> list[Tool]:
    """List available tools."""
    return [
        Tool(
            name="get_time_of_day",
            description="Returns current time of day: morning, afternoon, evening, night",
            inputSchema={
                "type": "object",
                "properties": {},
                "required": []
            }
        ),
        Tool(
            name="get_weather",
            description="Returns current weather condition for a city",
            inputSchema={
                "type": "object",
                "properties": {
                    "location": {
                        "type": "string",
                        "description": "City name",
                        "default": "Bangalore"
                    }
                },
                "required": []
            }
        )
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    """Handle tool calls."""
    if name == "get_time_of_day":
        hour = datetime.now().hour
        if 5 <= hour < 12:
            result = "morning"
        elif 12 <= hour < 17:
            result = "afternoon"
        elif 17 <= hour < 21:
            result = "evening"
        else:
            result = "night"
        
        return [TextContent(
            type="text",
            text=result
        )]
    
    elif name == "get_weather":
        location = arguments.get("location", "Bangalore")
        result = f"The weather in {location} is sunny with light clouds ðŸŒ¤ï¸"
        
        return [TextContent(
            type="text",
            text=result
        )]
    
    else:
        raise ValueError(f"Unknown tool: {name}")

async def main():
    """Run the MCP server."""
    async with stdio_server() as (read_stream, write_stream):
        await app.run(
            read_stream,
            write_stream,
            app.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
```

## 2. Agent with MCP Client (`agent_with_mcp.py`)

```python
# agent_with_mcp.py
import asyncio
from contextlib import AsyncExitStack
from typing import Sequence, Any, MutableMapping, Callable, AsyncIterable, Literal
from pydantic import BaseModel
from langchain_core.prompts import ChatPromptTemplate
from safechain.lcel import model
from agent_framework import ChatAgent, BaseChatClient
from agent_framework import ChatMessage, Role, TextContent, ChatOptions, ToolMode
from agent_framework import ChatResponse, ToolProtocol
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client


def extract_text_from_message(m: ChatMessage) -> str:
    """Extract text content from a ChatMessage."""
    if hasattr(m, "contents") and m.contents:
        c = m.contents[0]
        if hasattr(c, "text"):
            return c.text
        if hasattr(c, "value"):
            return c.value
        if hasattr(c, "data"):
            return c.data
    return ""


def greetings_prompt(user_input: str, time_of_day: str, weather: str) -> str:
    """Generate greeting prompt with context."""
    return f"""
You are a friendly, polite greeting assistant.

Time of day: {time_of_day}
Weather info: {weather}

Greet the user appropriately using the time and weather.

User input:
{user_input}

Keep the response short and friendly.
"""


def _merge_chat_options(
    *,
    base_chat_options: ChatOptions | Any | None = None,
    model_id: str | None = None,
    allow_multiple_tool_calls: bool | None = None,
    frequency_penalty: float | None = None,
    logit_bias: dict[str | int, float] | None = None,
    max_tokens: int | None = None,
    metadata: dict[str, Any] | None = None,
    presence_penalty: float | None = None,
    response_format: type[BaseModel] | None = None,
    seed: int | None = None,
    stop: str | Sequence[str] | None = None,
    store: bool | None = None,
    temperature: float | None = None,
    tool_choice: ToolMode | Literal["auto", "required", "none"] | dict[str, Any] | None = None,
    tools: list[ToolProtocol | dict[str, Any] | Callable[..., Any]] | None = None,
    top_p: float | None = None,
    user: str | None = None,
    additional_properties: dict[str, Any] | None = None,
) -> ChatOptions:
    """Merge base chat options with direct parameters to create a new ChatOptions instance."""
    # Validate base_chat_options type if provided
    if base_chat_options is not None and not isinstance(base_chat_options, ChatOptions):
        raise TypeError("chat_options must be an instance of ChatOptions")

    if base_chat_options is None:
        base_chat_options = ChatOptions()

    return base_chat_options & ChatOptions(
        model_id=model_id,
        allow_multiple_tool_calls=allow_multiple_tool_calls,
        frequency_penalty=frequency_penalty,
        logit_bias=logit_bias,
        max_tokens=max_tokens,
        metadata=metadata,
        presence_penalty=presence_penalty,
        response_format=response_format,
        seed=seed,
        stop=stop,
        store=store,
        temperature=temperature,
        top_p=top_p,
        tool_choice=tool_choice,
        tools=tools,
        user=user,
        additional_properties=additional_properties,
    )


# =========================================================
# CHAT CLIENT WITH MCP
# =========================================================
class MyChatClientWithMCP(BaseChatClient):
    def __init__(self):
        super().__init__()
        self.mcp_session: ClientSession | None = None
        self.mcp_exit_stack = None
        
    async def connect_mcp(self):
        """Connect to the local MCP server."""
        server_params = StdioServerParameters(
            command="python",
            args=["mcp_server.py"],
            env=None
        )
        
        # Use AsyncExitStack to manage context
        self.mcp_exit_stack = AsyncExitStack()
        
        # Enter the stdio_client context
        stdio_transport = await self.mcp_exit_stack.enter_async_context(
            stdio_client(server_params)
        )
        stdio, write = stdio_transport
        
        # Initialize MCP session
        self.mcp_session = ClientSession(stdio, write)
        await self.mcp_session.initialize()
        
        # List available tools
        tools_list = await self.mcp_session.list_tools()
        print(f"âœ… Connected to MCP. Tools: {[t.name for t in tools_list.tools]}")
        
    async def call_mcp_tool(self, tool_name: str, arguments: dict = None) -> str:
        """Call a tool via MCP."""
        if not self.mcp_session:
            raise RuntimeError("MCP session not initialized. Call connect_mcp() first.")
        
        result = await self.mcp_session.call_tool(tool_name, arguments or {})
        
        # Extract text from result
        if result.content and len(result.content) > 0:
            return result.content[0].text
        return ""
    
    async def _inner_get_response(
        self,
        messages: Sequence[ChatMessage],
        *,
        tools: Sequence[ToolProtocol] | None = None,
        tool_choice: Callable[..., Any] | None = None,
        chat_options: MutableMapping[str, Any] | None = None,
        **kwargs: Any,
    ) -> ChatResponse:

        # Ensure MCP connection
        if not self.mcp_session:
            await self.connect_mcp()

        # Initialize with defaults
        time_of_day = "unknown"
        weather_info = "unavailable"
        
        # Extract user message
        user_message = extract_text_from_message(messages[-1])
        
        # Call MCP tools
        try:
            print("ðŸ”§ Calling get_time_of_day via MCP...")
            time_of_day = await self.call_mcp_tool("get_time_of_day")
            print(f"âœ… Time of day: {time_of_day}")
            
            print("ðŸ”§ Calling get_weather via MCP...")
            weather_info = await self.call_mcp_tool("get_weather", {"location": "Bangalore"})
            print(f"âœ… Weather: {weather_info}")
            
        except Exception as e:
            print(f"âŒ MCP tool execution error: {e}")

        # Build prompt with tool results
        prompt_content = greetings_prompt(
            user_message,
            time_of_day=time_of_day,
            weather=weather_info,
        )
        
        prompt_template = ChatPromptTemplate.from_messages([
            (messages[-1].role.value, prompt_content)
        ])

        prompt_value = prompt_template.format_prompt()
        llm = model("3")
        llm_response = llm.invoke(prompt_value)

        response_message = ChatMessage(
            role=Role.ASSISTANT,
            contents=[TextContent(text=llm_response.content)],
        )

        return ChatResponse(messages=response_message)

    async def _inner_get_streaming_response(
        self,
        messages: Sequence[ChatMessage],
        *,
        tools: Sequence[ToolProtocol] | None = None,
        tool_choice: Callable[..., Any] | None = None,
        chat_options: MutableMapping[str, Any] | None = None,
        **kwargs: Any,
    ) -> AsyncIterable[ChatResponse]:
        raise NotImplementedError("Streaming not implemented")
    
    async def cleanup(self):
        """Cleanup MCP connection."""
        if self.mcp_exit_stack:
            await self.mcp_exit_stack.aclose()
            print("âœ… MCP connection closed")


class GreetingAgentWithMCP(ChatAgent):
    def __init__(self):
        chat_client = MyChatClientWithMCP()
        super().__init__(
            name="GreetingAgentMCP",
            chat_client=chat_client,
            instructions="You are a friendly greeting assistant with MCP tools.",
        )
    
    async def cleanup(self):
        """Cleanup resources."""
        await self.chat_client.cleanup()


async def main():
    agent = GreetingAgentWithMCP()
    
    try:
        print("ðŸš€ Starting greeting agent with MCP...\n")
        response = await agent.run("Hi there!")
        print("\nâœ¨ FINAL RESPONSE:")
        print(response.text)
    finally:
        await agent.cleanup()
        print("\nðŸ‘‹ Cleaned up MCP connection")


if __name__ == "__main__":
    asyncio.run(main())
```

## Key Changes Made:

1. **Added import**: `from contextlib import AsyncExitStack`
2. **Updated `__init__`**: Added `self.mcp_exit_stack = None`
3. **Fixed `connect_mcp`**: Uses `AsyncExitStack` to properly manage the `stdio_client` context manager
4. **Fixed `cleanup`**: Uses `aclose()` on the exit stack

## To Run:

```bash
# Install dependencies
pip install mcp agent-framework langchain-core

# Run the agent (it will automatically start the MCP server)
python agent_with_mcp.py
```

The error you were getting is now fixed because we're properly handling the async context manager returned by `stdio_client()`.
