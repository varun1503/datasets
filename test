# agents/activities_agent.py
import os
import json
from dotenv import load_dotenv
from google.adk.agents import Agent
from google.genai import types

from common.pg_store import PostgresStore
from common.memory_runner import MemoryRunner

load_dotenv()

APP_NAME = os.getenv("APP_NAME", "travel_assistant")
USER_ID = os.getenv("SHARED_USER_ID", "global_user")
SESSION_ID = os.getenv("SHARED_SESSION_ID", "global_session")

# define agent
activities_agent = Agent(
    name="activities_agent",
    model='gemini-1.5-flash',
    description="Suggests interesting activities for the user at a destination.",
    instruction=(
        "Given a destination, dates, and budget, suggest 2-3 activities..."
    )
)

# shared Postgres-backed session service (same instance can be reused across agents if you want)
session_service = PostgresStore()

# runner that injects memory
runner = MemoryRunner(agent=activities_agent, app_name=APP_NAME, session_service=session_service)

async def execute(request: dict):
    """
    request: {destination, start_date, end_date, budget}
    """
    # Build prompt and types.Content per ADK API you use
    prompt = (
        f"User is flying to {request['destination']} from {request['start_date']} to {request['end_date']}, "
        f"with a budget of {request['budget']}. Suggest 2-3 activities, each with name, description, price estimate, and duration. "
        f"Respond in JSON format using the key 'activities' with a list of activity objects."
    )
    message = types.Content(role="user", parts=[types.Part(text=prompt)])

    # Persist the user message in DB
    # Convert message to serializable form
    content_json = {"parts": [p.model_dump() if hasattr(p, "model_dump") else {"text": getattr(p, "text", "")} for p in message.parts]}
    await session_service.save_message(app_name=APP_NAME, agent_name="activities_agent", user_id=USER_ID, session_id=SESSION_ID, role="user", content=content_json)

    # Run the agent (MemoryRunner will inject previous history + facts)
    async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=message):
        if event.is_final_response():
            # save assistant reply
            assistant_content = {"parts": [p.model_dump() if hasattr(p, "model_dump") else {"text": getattr(p, "text", "")} for p in event.content.parts]}
            await session_service.save_message(app_name=APP_NAME, agent_name="activities_agent", user_id=USER_ID, session_id=SESSION_ID, role="assistant", content=assistant_content)

            response_text = event.content.parts[0].text
            try:
                parsed = json.loads(response_text)
                return {"activities": parsed.get("activities", response_text)}
            except json.JSONDecodeError:
                return {"activities": response_text}
