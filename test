from docx import Document
from docx.shared import Pt, Inches, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.table import WD_ALIGN_VERTICAL
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
import os
import json
import ast
from typing import Optional, Any
import pandas as pd


def add_title_to_top(doc: Document, model, impact, scope, title_text="Validation Report (Template)"):
    # Insert a paragraph at the very beginning
    if doc.paragraphs:
        p = doc.paragraphs[0].insert_paragraph_before()
    else:
        p = doc.add_paragraph()
    r = p.add_run(title_text)
    r.bold = True
    r.font.size = Pt(16)
    p.alignment = WD_ALIGN_PARAGRAPH.CENTER

    # Subtitle line beneath the title
    sub = doc.add_paragraph()
    sub_run = sub.add_run(f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}")
    sub_run.font.size = Pt(11)

    # Spacer
    doc.add_paragraph()
    return doc


# ---------- helpers ----------
def _bold_run(p, text, size=11):
    r = p.add_run(text)
    r.bold = True
    r.font.size = Pt(size)
    return r

def _normal_run(p, text, size=11):
    r = p.add_run(text)
    r.font.size = Pt(size)
    return r

def safe_json_loads(cell: Any):
    """Pass-through for dict/list; try json/literal for strings."""
    if isinstance(cell, (dict, list)) or cell is None:
        return cell
    if not isinstance(cell, str):
        return cell
    try:
        return json.loads(cell)
    except Exception:
        pass
    try:
        return ast.literal_eval(cell)
    except Exception:
        return cell

def _add_heading(doc: Document, text: str, size=12):
    p = doc.add_paragraph()
    _bold_run(p, text, size=size)

def _add_rfr_block(doc: Document, rfr_obj: Any):
    """
    Render an RFR section from a dict like {"Q1": "answer ...", "Q2": "..."}.
    Also tolerates JSON-ish strings by parsing first.
    """
    rfr_obj = safe_json_loads(rfr_obj)
    if not rfr_obj:
        _normal_run(doc.add_paragraph(), "(No RFR provided)")
        return

    if isinstance(rfr_obj, dict):
        for k, v in rfr_obj.items():
            # Question key (bold)
            p_q = doc.add_paragraph()
            _bold_run(p_q, f"{str(k).strip()}: ", size=11)

            # Response/value
            p_a = doc.add_paragraph()
            _bold_run(p_a, "Response: ", size=11)
            _normal_run(p_a, str(v).strip())
    else:
        # Fallback dump
        _normal_run(doc.add_paragraph(), str(rfr_obj).strip())

def _as_finding_lines(x: Any):
    """
    Normalize findings to list[str]. Accepts list/ dict / string / JSON-ish.
    """
    x = safe_json_loads(x)
    if x is None:
        return []
    if isinstance(x, list):
        return [str(it).strip() for it in x if str(it).strip()]
    if isinstance(x, dict):
        return [f"{k}: {v}" for k, v in x.items() if str(v).strip()]
    if isinstance(x, str):
        s = x.strip()
        return [s] if s else []
    return [str(x).strip()]


# ---------- table styling helpers ----------
def _set_cell_bg(cell, hex_color: str = "000000"):
    """Set solid background fill for a cell via oXML."""
    tc_pr = cell._tc.get_or_add_tcPr()
    shd = tc_pr.find(qn('w:shd'))
    if shd is None:
        shd = OxmlElement('w:shd')
        tc_pr.append(shd)
    shd.set(qn('w:fill'), hex_color)     # background color
    shd.set(qn('w:val'), 'clear')        # no pattern
    shd.set(qn('w:color'), 'auto')

def _format_header_cell(cell):
    """White, bold, centered text for header cells."""
    cell.vertical_alignment = WD_ALIGN_VERTICAL.CENTER
    for p in cell.paragraphs:
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        for r in p.runs:
            r.font.bold = True
            r.font.color.rgb = RGBColor(255, 255, 255)
            r.font.size = Pt(11)

def _force_table_borders(table):
    """
    Ensure visible grid borders even if 'Table Grid' style is unavailable.
    """
    tbl = table._tbl
    tblPr = tbl.tblPr or OxmlElement('w:tblPr')
    if tbl.tblPr is None:
        tbl.append(tblPr)

    borders = tblPr.find(qn('w:tblBorders'))
    if borders is None:
        borders = OxmlElement('w:tblBorders')
        tblPr.append(borders)

    def _add_border(tag):
        el = borders.find(qn(f'w:{tag}'))
        if el is None:
            el = OxmlElement(f'w:{tag}')
            borders.append(el)
        el.set(qn('w:val'), 'single')
        el.set(qn('w:sz'), '8')     # thickness
        el.set(qn('w:space'), '0')
        el.set(qn('w:color'), '000000')

    for edge in ['top', 'left', 'bottom', 'right', 'insideH', 'insideV']:
        _add_border(edge)


# ---------- findings table ----------
def _add_findings_table(doc: Document, findings_df: Optional[pd.DataFrame]):
    """
    Insert a 'Findings' heading and a table with the specified columns, if data exists.
    Header row will be black with white bold text; table has a visible grid outline.
    Expected columns (case-insensitive tolerant):
      - IMVP question
      - Finding Impact Category
      - Finding Details
      - Finding Status
    """
    if findings_df is None or len(findings_df) == 0:
        return

    # Normalize column names for tolerant matching
    colmap = {c.lower().strip(): c for c in findings_df.columns}

    def pick(*aliases):
        for a in aliases:
            if a.lower() in colmap:
                return colmap[a.lower()]
        return None

    col_imvp    = pick("IMVP question", "IMVP Question", "imvp_question", "imvp q", "imvp")
    col_impact  = pick("Finding Impact Category", "Impact Category", "finding impact category", "impact")
    col_detail  = pick("Finding Details", "Finding Detail", "details", "finding details")
    col_status  = pick("Finding Status", "Status", "finding status")

    cols = [col_imvp, col_impact, col_detail, col_status]

    _add_heading(doc, "Findings", size=12)

    if not all(cols):
        _normal_run(doc.add_paragraph(), "(Findings table skipped: required columns not found)")
        doc.add_paragraph()
        return

    # Create table
    table = doc.add_table(rows=1, cols=4)
    # Try style; force borders regardless to be safe
    try:
        table.style = "Table Grid"
    except Exception:
        pass
    _force_table_borders(table)

    table.autofit = False  # avoid Word auto-shrink for long text

    # Set column widths (tweak as needed)
    widths = [Inches(1.8), Inches(1.8), Inches(3.8), Inches(1.6)]
    for i, w in enumerate(widths):
        for cell in table.columns[i].cells:
            cell.width = w

    # Header row (black background)
    hdr = table.rows[0].cells
    hdr[0].text = "IMVP Question"
    hdr[1].text = "Finding Impact Category"
    hdr[2].text = "Finding Details"
    hdr[3].text = "Finding Status"

    for cell in hdr:
        _set_cell_bg(cell, "000000")
        _format_header_cell(cell)

    # Data rows
    for _, r in findings_df.iterrows():
        row_cells = table.add_row().cells
        row_cells[0].text = str(r.get(col_imvp, "") or "").strip()
        row_cells[1].text = str(r.get(col_impact, "") or "").strip()
        row_cells[2].text = str(r.get(col_detail, "") or "").strip()
        row_cells[3].text = str(r.get(col_status, "") or "").strip()

        # Alignments and body font
        for c in row_cells:
            c.vertical_alignment = WD_ALIGN_VERTICAL.CENTER
            for p in c.paragraphs:
                p.alignment = WD_ALIGN_PARAGRAPH.LEFT
                for run in p.runs:
                    run.font.size = Pt(10)

    # Spacer after table
    doc.add_paragraph()


# ---------- main ----------
def build_simple_template(
    df: pd.DataFrame,
    model: str,
    impact: str,
    prepend_docx_path: str,
    scope: str = "",
    save_dir: str = "base",
    *,
    findings_df: Optional[pd.DataFrame] = None,   # pass your Excel dataframe here
    question_col: str = "text",
    sections_col: str = "sections",
    mrmg_col: Optional[str] = "mrmg_answer",
    heading_col: Optional[str] = None,            # if you have one
    rfr_col: str = "RFR",                         # your dict column (already set)
    finding_col: Optional[str] = "Findings",
    page_break: bool = True,
    blank_lines_under_mtr: int = 2
) -> str:
    # sanity
    for col in [question_col, sections_col]:
        if col not in df.columns:
            raise KeyError(f"Missing required column: {col}")

    os.makedirs(save_dir, exist_ok=True)
    out_path = os.path.join(save_dir, f"{model}_{impact}{('_' + scope) if scope else ''}.docx")

    doc = Document(prepend_docx_path) if prepend_docx_path else Document()

    # Title + (optional page break)
    add_title_to_top(doc, model=model, impact=impact, scope=scope)
    if prepend_docx_path and page_break:
        doc.add_page_break()

    # Insert FINDINGS section + table right after prepend/title
    _add_findings_table(doc, findings_df)

    # Rows for Q/A, Sections, RFR, etc.
    for i, row in df.iterrows():
        # Question
        pq = doc.add_paragraph()
        _bold_run(pq, f"Question {i+1}: ", size=12)
        _normal_run(pq, str(row[question_col]).strip())
        doc.add_paragraph()

        # Section
        ps = doc.add_paragraph()
        _bold_run(ps, "Section: ")
        _normal_run(ps, str(row[sections_col]).strip())
        doc.add_paragraph()

        # Optional Heading
        if heading_col and heading_col in df.columns:
            ph = doc.add_paragraph()
            _bold_run(ph, "Heading: ")
            _normal_run(ph, str(row.get(heading_col, "")).strip())
            doc.add_paragraph()

        # MRMG Assessment (if present)
        if mrmg_col and mrmg_col in df.columns:
            pm = doc.add_paragraph()
            _bold_run(pm, "MRMG Assessment: ")
            _normal_run(pm, str(row.get(mrmg_col, "")).strip())
            doc.add_paragraph()

        # RFR
        if rfr_col in df.columns:
            _add_heading(doc, "RFR", size=12)
            _add_rfr_block(doc, row.get(rfr_col))

        # Findings (per-question free text list, if you still want it)
        if finding_col and finding_col in df.columns:
            _add_heading(doc, "Findings", size=12)
            lines = _as_finding_lines(row.get(finding_col))
            if lines:
                for line in lines:
                    p = doc.add_paragraph(style=None)
                    try:
                        p.style = doc.styles['List Bullet']  # bullet style if available
                    except Exception:
                        pass
                    _normal_run(p, line)
            else:
                _normal_run(doc.add_paragraph(), "(No findings provided)")

        # Modelling Team Response (space)
        pmt = doc.add_paragraph()
        _bold_run(pmt, "Modelling Team Response", size=11)
        for _ in range(max(0, blank_lines_under_mtr)):
            doc.add_paragraph()
        # spacer
        doc.add_paragraph()

    doc.save(out_path)
    return out_path
