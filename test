import re
import json
import unicodedata
import os
from pathlib import Path
from typing import List, Dict, Optional

import pandas as pd
from docx import Document
from docx.oxml.ns import qn
from docx.table import Table
from docx.text.paragraph import Paragraph


# ==================== NORMALIZATION ====================

def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", " ")
    return re.sub(r"\s+", " ", s).strip()


# ==================== DOCX READING ====================

def read_docx_lines(path: str) -> List[str]:
    doc = Document(path)
    lines = []

    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                lines.append(t)

        elif child.tag == qn("w:tbl"):
            tbl = Table(child, doc)
            for row in tbl.rows:
                cells = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            cells.append(t)
                if cells:
                    lines.append(" | ".join(cells))

    return lines


# ==================== REGEX ====================

REQ_ITEMS_RX = re.compile(r"Request\s+Items", re.IGNORECASE)
RFR_RX = re.compile(r"\bRFR\s*\d+", re.IGNORECASE)
RESP_HDR_RX = re.compile(r"Modell?ing Team['’]?s Response", re.IGNORECASE)
BRACKETS_RX = re.compile(r"<\s*([^>]+?)\s*>")
Q_KEY_RX = re.compile(r"Q\d+\s*:", re.IGNORECASE)
TEST_TAG_RX = re.compile(r"<\s*Test\s*(\w+)\s*>", re.IGNORECASE)


# ==================== META EXTRACTION ====================

def extract_meta_from_rfr_header(line: str):
    parts = [norm(x) for x in BRACKETS_RX.findall(line)]

    rfr_q = ""
    section = ""
    imvp = ""
    test_tag = ""

    for p in parts:
        if Q_KEY_RX.search(p):
            rfr_q = Q_KEY_RX.sub("", p).strip()
            break

    for p in parts:
        if p.endswith("?") and p != rfr_q:
            imvp = p

    for p in parts:
        if p != rfr_q and not p.endswith("?") and not p.lower().startswith("test"):
            section = p
            break

    m = TEST_TAG_RX.search(line)
    if m:
        test_tag = m.group(1).upper()

    return rfr_q, section, imvp, test_tag


# ==================== HELPERS ====================

def is_only_bullets(text: str) -> bool:
    t = text.lower()
    t = re.sub(r'\b[ivx]+\.', '', t)
    t = re.sub(r'\b[a-z]\)', '', t)
    return not t.strip()


def clean_f_key(text: str, fallback: str) -> str:
    if not text or is_only_bullets(text):
        return fallback
    return text.strip()


# ==================== CORE PARSER ====================

def parse_lines_after_request_items(lines: List[str]) -> List[Dict]:
    start = 0
    for i, t in enumerate(lines):
        if REQ_ITEMS_RX.search(t):
            start = i + 1
            break

    L = lines[start:]
    rows = []
    i = 0

    while i < len(L):
        line = L[i]

        if RFR_RX.search(line):
            rfr_q, section, imvp, test_tag = extract_meta_from_rfr_header(line)

            f_items: Dict[str, str] = {}
            direct_response = ""

            current_f_key = None
            in_block = False
            buffer = []
            collecting_response = False

            i += 1

            while i < len(L) and not RFR_RX.search(L[i]):
                cur = L[i].strip()

                # -------- RESPONSE HEADER --------
                if RESP_HDR_RX.search(cur):
                    collecting_response = True
                    i += 1
                    continue

                # -------- OPEN < --------
                if cur.startswith("<"):
                    in_block = True
                    buffer = []

                    f_match = re.search(r'<\s*F(\d+)\s*:\s*(.*)', cur, re.IGNORECASE)
                    if f_match:
                        f_num = f"F{f_match.group(1)}"
                        f_text = clean_f_key(f_match.group(2).strip(), f_num)
                        current_f_key = f_text

                        rest = f_match.group(2).strip()
                        if rest:
                            buffer.append(rest)

                    i += 1
                    continue

                # -------- CLOSE > --------
                if cur.startswith(">"):
                    content = norm(" ".join(buffer))
                    in_block = False

                    if collecting_response:
                        if current_f_key:
                            f_items[current_f_key] = content
                        else:
                            direct_response = content
                        collecting_response = False

                    buffer = []
                    i += 1
                    continue

                # -------- COLLECT --------
                if in_block:
                    buffer.append(cur)
                    i += 1
                    continue

                i += 1

            # -------- BUILD OUTPUT --------
            rfr_payload = {}

            if f_items:
                rfr_payload = f_items
            elif direct_response:
                rfr_payload = {"response": direct_response}

            if rfr_payload:
                row = {
                    "IMVP Question": imvp,
                    "Section": section,
                    "rfr": {rfr_q: rfr_payload},
                }

                if test_tag:
                    row["Test Tag"] = test_tag

                rows.append(row)

            continue

        i += 1

    return rows


# ==================== MAIN ====================

def main():
    DOCX_PATH = "rfrtest.docx"
    OUT_JSON = "rfr_rows.json"
    OUT_CSV = "rfr_rows.csv"

    if not Path(DOCX_PATH).exists():
        print("❌ DOCX file not found")
        return

    lines = read_docx_lines(DOCX_PATH)
    rows = parse_lines_after_request_items(lines)

    with open(OUT_JSON, "w", encoding="utf-8") as f:
        json.dump(rows, f, indent=2, ensure_ascii=False)

    df = pd.DataFrame({"finding": rows})
    df["file name"] = os.path.basename(DOCX_PATH)
    df["type"] = "rfr"
    df.to_csv(OUT_CSV, index=False)

    print("✅ Parsing completed successfully")


if __name__ == "__main__":
    main()
