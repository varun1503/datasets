from docx import Document
from docx.shared import Pt, Inches, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_BREAK
from docx.enum.table import WD_TABLE_ALIGNMENT, WD_ALIGN_VERTICAL
from docx.oxml import OxmlElement
from docx.oxml.ns import qn

import os
import json
import ast
from typing import Optional, Any
import pandas as pd

EMU_PER_INCH = 914400

# ======================= Basic text helpers =======================

def _bold_run(p, text, size=11):
    r = p.add_run(text)
    r.bold = True
    r.font.size = Pt(size)
    return r

def _normal_run(p, text, size=11):
    r = p.add_run(text)
    r.font.size = Pt(size)
    return r

def safe_json_loads(cell: Any):
    """Pass-through for dict/list; try json/literal for strings."""
    if isinstance(cell, (dict, list)) or cell is None:
        return cell
    if not isinstance(cell, str):
        return cell
    try:
        return json.loads(cell)
    except Exception:
        pass
    try:
        return ast.literal_eval(cell)
    except Exception:
        return cell

def _add_heading(doc: Document, text: str, size=12):
    p = doc.add_paragraph()
    _bold_run(p, text, size=size)

def _add_rfr_block(doc: Document, rfr_obj: Any):
    """
    Render an RFR section from a dict like {"Q1": "...", "Q2": "..."}.
    Also tolerates JSON-ish strings by parsing first.
    """
    rfr_obj = safe_json_loads(rfr_obj)
    if not rfr_obj:
        _normal_run(doc.add_paragraph(), "(No RFR provided)")
        return

    if isinstance(rfr_obj, dict):
        for k, v in rfr_obj.items():
            p_q = doc.add_paragraph()
            _bold_run(p_q, f"{str(k).strip()}: ", size=11)

            p_a = doc.add_paragraph()
            _bold_run(p_a, "Response: ", size=11)
            _normal_run(p_a, str(v).strip())
    else:
        _normal_run(doc.add_paragraph(), str(rfr_obj).strip())

def _as_finding_lines(x: Any):
    """Normalize findings to list[str]. Accepts list/dict/string/JSON-ish."""
    x = safe_json_loads(x)
    if x is None:
        return []
    if isinstance(x, list):
        return [str(it).strip() for it in x if str(it).strip()]
    if isinstance(x, dict):
        return [f"{k}: {v}" for k, v in x.items() if str(v).strip()]
    if isinstance(x, str):
        s = x.strip()
        return [s] if s else []
    return [str(x).strip()]

# ======================= Table styling helpers =======================

def _set_cell_bg(cell, hex_color: str = "000000"):
    """Set solid background fill for a cell via oXML."""
    tc_pr = cell._tc.get_or_add_tcPr()
    shd = tc_pr.find(qn('w:shd'))
    if shd is None:
        shd = OxmlElement('w:shd')
        tc_pr.append(shd)
    shd.set(qn('w:fill'), hex_color)     # background color
    shd.set(qn('w:val'), 'clear')        # no pattern
    shd.set(qn('w:color'), 'auto')

def _format_header_cell(cell):
    """White, bold, centered text for header cells."""
    cell.vertical_alignment = WD_ALIGN_VERTICAL.CENTER
    for p in cell.paragraphs:
        p.alignment = WD_ALIGN_PARAGRAPH.CENTER
        for r in p.runs:
            r.font.bold = True
            r.font.color.rgb = RGBColor(255, 255, 255)
            r.font.size = Pt(11)

def _force_table_borders(table, color="000000", size=8):
    """Ensure visible grid borders even if 'Table Grid' style is unavailable."""
    tbl = table._tbl
    tblPr = tbl.tblPr or OxmlElement('w:tblPr')
    if tbl.tblPr is None:
        tbl.append(tblPr)
    borders = tblPr.find(qn('w:tblBorders'))
    if borders is None:
        borders = OxmlElement('w:tblBorders')
        tblPr.append(borders)
    for edge in ['top', 'left', 'bottom', 'right', 'insideH', 'insideV']:
        el = borders.find(qn(f'w:{edge}'))
        if el is None:
            el = OxmlElement(f'w:{edge}')
            borders.append(el)
        el.set(qn('w:val'), 'single')
        el.set(qn('w:sz'), str(size))
        el.set(qn('w:space'), '0')
        el.set(qn('w:color'), color)

# ======================= Findings table (5 columns, fits page) =======================

def _emu_to_inches(v):  # EMU -> inches
    return float(v) / EMU_PER_INCH

def _add_findings_table(doc: Document, findings_df: Optional[pd.DataFrame]):
    """
    Render a 5-column Findings table:
      ['IMVP question','Risk Pillar','Finding Impact Category','Finding Details','Finding status'].
    Widths are set to fit within the page (no overflow), giving most width to 'Finding Details'.
    """
    if findings_df is None or len(findings_df) == 0:
        return

    # Use your known column names (case-sensitive from your screenshot)
    required = ["IMVP question", "Risk Pillar", "Finding Impact Category",
                "Finding Details", "Finding status"]
    missing = [c for c in required if c not in findings_df.columns]
    if missing:
        p = doc.add_paragraph()
        r = p.add_run("Findings (required columns missing: " + ", ".join(missing) + ")")
        r.bold = True
        return

    # Heading & caption
    sec = doc.add_paragraph()
    sr = sec.add_run("Findings")
    sr.bold = True
    sr.font.size = Pt(12)

    cap = doc.add_paragraph("Summary of Findings")
    cap.alignment = WD_ALIGN_PARAGRAPH.CENTER
    cap.runs[0].bold = True
    cap.runs[0].font.size = Pt(12)

    headers = ["IMVP question", "Risk Pillar", "Finding Impact Category", "Finding Details", "Finding status"]
    table = doc.add_table(rows=1, cols=len(headers))
    table.alignment = WD_TABLE_ALIGNMENT.CENTER
    table.autofit = False
    _force_table_borders(table, "000000")

    # Header row
    hdr = table.rows[0].cells
    for i, h in enumerate(headers):
        hdr[i].text = h
        _set_cell_bg(hdr[i], "000000")
        _format_header_cell(hdr[i])

    # Usable width (subtract margins) + small safety margin
    secn = doc.sections[-1]
    usable_in = _emu_to_inches(secn.page_width - secn.left_margin - secn.right_margin) - 0.05

    # Assign narrow widths to short columns, give remainder to 'Finding Details'
    # [IMVP q, Risk Pillar, Impact, Details, Status]
    base = [1.20, 1.20, 1.50, 3.50, 1.20]
    other = base[0] + base[1] + base[2] + base[4]
    details_width = max(3.0, usable_in - other)
    widths = [base[0], base[1], base[2], details_width, base[4]]

    # If rounding leaves tiny mismatch, force exact fit on last col
    diff = usable_in - sum(widths)
    if abs(diff) > 1e-3:
        widths[-1] = max(1.0, widths[-1] + diff)

    # Apply widths
    for i, w_in in enumerate(widths):
        for cell in table.columns[i].cells:
            cell.width = Inches(w_in)

    # Data rows
    for _, r in findings_df.iterrows():
        row = table.add_row().cells
        row[0].text = str(r.get("IMVP question", "")).strip()
        row[1].text = str(r.get("Risk Pillar", "")).strip()
        row[2].text = str(r.get("Finding Impact Category", "")).strip()
        row[3].text = str(r.get("Finding Details", "")).strip()
        row[4].text = str(r.get("Finding status", "")).strip()
        for c in row:
            c.vertical_alignment = WD_ALIGN_VERTICAL.CENTER
            for p in c.paragraphs:
                p.alignment = WD_ALIGN_PARAGRAPH.LEFT
                for run in p.runs:
                    run.font.size = Pt(10)

    doc.add_paragraph()  # spacer

# ======================= Section 2: Finding Details (fixed subsections) =======================

def _add_section2_finding_details(doc: Document, findings_df: Optional[pd.DataFrame]):
    """
    Render:
      2. Finding Details
         2.1 Model Documentation
             Finding
               - <Finding Details...>   (rows where Risk Pillar maps to this subsection)
             (or) No findings were issued for Model Documentation.
         ...
         2.7 Governance
    """
    # Even with no data, print the skeleton
    if findings_df is None:
        findings_df = pd.DataFrame(columns=["Risk Pillar", "Finding Details"])

    # Column resolution (tolerant)
    colmap = {str(c).strip().lower(): c for c in findings_df.columns}
    def pick(*aliases):
        for a in aliases:
            k = str(a).strip().lower()
            if k in colmap:
                return colmap[k]
        return None

    c_pillar  = pick("risk pillar", "pillar")
    c_details = pick("finding details", "finding detail", "details")

    # Top-level section heading
    _bold_run(doc.add_paragraph(), "2. Finding Details", size=12)

    # Canonical subsections + matching keys (normalized)
    subsections = [
        ("2.1", "Model Documentation",      ["model documentation"]),
        ("2.2", "Model Objective & Use",    ["model objective and use", "model objective & use", "model objective", "objective & use"]),
        ("2.3", "Data Validation",          ["data validation"]),
        ("2.4", "Theory & Approach",        ["theory and approach", "theory & approach", "approach & theory", "approach"]),
        ("2.5", "Outcome Analysis",         ["outcome analysis"]),
        ("2.6", "Ongoing Monitoring",       ["ongoing monitoring", "monitoring"]),
        ("2.7", "Governance",               ["governance"]),
    ]

    def norm(s: str) -> str:
        if s is None:
            return ""
        s = str(s).lower().strip().replace("&", "and")
        return " ".join(s.split())

    # Prepare normalized series if columns exist
    if c_pillar and c_details:
        norm_pillar = findings_df[c_pillar].map(norm)
        details_series = findings_df[c_details].astype(str).fillna("").map(lambda s: s.strip())
    else:
        norm_pillar = pd.Series([], dtype=str)
        details_series = pd.Series([], dtype=str)

    # Render each subsection
    for num, title, keys in subsections:
        # Subsection heading (e.g., "2.1 Model Documentation")
        _bold_run(doc.add_paragraph(), f"{num} {title}", size=11)

        # "Finding" label
        _bold_run(doc.add_paragraph(), "Finding", size=11)

        has_cols = (c_pillar is not None) and (c_details is not None)
        if has_cols:
            keyset = {norm(k) for k in keys}
            mask = norm_pillar.isin(keyset)
            rows = details_series[mask]
        else:
            rows = pd.Series([], dtype=str)

        if len(rows) == 0:
            _normal_run(doc.add_paragraph(), f"No findings were issued for {title}.", size=10)
            doc.add_paragraph()
            continue

        # Deduplicate details while preserving order
        seen = set()
        for detail in rows:
            if not detail or detail in seen:
                continue
            seen.add(detail)
            p = doc.add_paragraph()
            try:
                p.style = doc.styles['List Bullet']
            except Exception:
                pass
            _normal_run(p, detail, size=10)

        doc.add_paragraph()  # spacer

# ======================= Title + (optional) TOC at very top =======================

def _insert_page_break_before(anchor_para):
    """Insert a page break immediately before `anchor_para`."""
    p = anchor_para.insert_paragraph_before()
    run = p.add_run()
    run.add_break(WD_BREAK.PAGE)

def _insert_paragraph_before(anchor_para, text="", bold=False, align=None, font_size_pt=None, left_indent_in=None):
    """Insert a formatted paragraph immediately before `anchor_para`."""
    p = anchor_para.insert_paragraph_before(text)
    if p.runs and bold:
        p.runs[0].bold = True
    if p.runs and font_size_pt:
        p.runs[0].font.size = Pt(font_size_pt)
    if align is not None:
        p.alignment = align
    if left_indent_in is not None:
        p.paragraph_format.left_indent = Inches(left_indent_in)
    return p

def _gather_toc_lines(toc_node, level=0):
    """Depth-first traversal of toc_dict -> list of (text, level)."""
    lines = []
    if isinstance(toc_node, dict):
        for heading, child in toc_node.items():
            lines.append((str(heading), level))
            if isinstance(child, dict) and child:
                lines.extend(_gather_toc_lines(child, level+1))
    return lines

def add_title_and_toc_at_top(
    doc: Document,
    model: str,
    impact: str,
    scope: str,
    model_id: str,
    model_version: str,
    model_name: str,
    report_date: str,
    toc_dict: dict,
):
    """
    Insert at the very start in CORRECT visual order:
      Title, Subtitle, Spacer,
      Page Break,
      'Table of Contents' heading,
      TOC items (top -> bottom),
      Page Break,
      then original prepend content.
    """
    # Ensure anchor
    if doc.paragraphs:
        anchor = doc.paragraphs[0]
    else:
        doc.add_paragraph()
        anchor = doc.paragraphs[0]

    # 1) Title
    title_text = (
        f"Model ID: {model_id}, "
        f"Model Version: {model_version}, "
        f"Model Name: {model_name}, "
        f"Date of Report Generation: {report_date}"
    )
    _insert_paragraph_before(
        anchor_para=anchor,
        text=title_text,
        bold=True,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=16
    )
    # 2) Subtitle
    _insert_paragraph_before(
        anchor_para=anchor,
        text=f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}",
        bold=False,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=11
    )
    # 3) Spacer
    _insert_paragraph_before(anchor_para=anchor, text="")

    # 4) Page break (between title and TOC)
    _insert_page_break_before(anchor)

    # 5) TOC heading
    _insert_paragraph_before(
        anchor_para=anchor,
        text="Table of Contents",
        bold=True,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=14
    )

    # 6) TOC items in NATURAL ORDER (no reversed)
    toc_lines = _gather_toc_lines(toc_dict, level=0)
    for text, level in toc_lines:
        _insert_paragraph_before(
            anchor_para=anchor,
            text=text,
            bold=False,
            align=None,
            font_size_pt=11,
            left_indent_in=0.25 * level  # indent per level
        )

    # 7) Page break (after TOC, before original content)
    _insert_page_break_before(anchor)

def add_title_only_top(
    doc: Document,
    model: str,
    impact: str,
    scope: str,
    model_id: str,
    model_version: str,
    model_name: str,
    report_date: str,
):
    """Insert only the title + subtitle at the very top (no TOC)."""
    if doc.paragraphs:
        anchor = doc.paragraphs[0]
    else:
        doc.add_paragraph()
        anchor = doc.paragraphs[0]

    _insert_paragraph_before(anchor_para=anchor, text="")  # spacer
    _insert_paragraph_before(
        anchor_para=anchor,
        text=f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}",
        bold=False,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=11
    )
    title_text = (
        f"Model ID: {model_id}, "
        f"Model Version: {model_version}, "
        f"Model Name: {model_name}, "
        f"Date of Report Generation: {report_date}"
    )
    _insert_paragraph_before(
        anchor_para=anchor,
        text=title_text,
        bold=True,
        align=WD_ALIGN_PARAGRAPH.CENTER,
        font_size_pt=16
    )

# ======================= Main =======================

def build_simple_template(
    df: pd.DataFrame,
    model: str,
    impact: str,
    model_id: str,
    model_version: str,
    model_name: str,
    report_date: str,
    prepend_docx_path: str,
    *,
    toc_dict: Optional[dict] = None,           # optional TOC dict
    scope: str = "",
    save_dir: str = "base",
    findings_df: Optional[pd.DataFrame] = None,   # Excel findings df
    question_col: str = "text",
    sections_col: str = "sections",
    mrmg_col: Optional[str] = "mrmg_answer",
    heading_col: Optional[str] = None,
    rfr_col: str = "RFR",
    finding_col: Optional[str] = "Findings",
    blank_lines_under_mtr: int = 2
) -> str:
    # sanity
    for col in [question_col, sections_col]:
        if col not in df.columns:
            raise KeyError(f"Missing required column: {col}")

    os.makedirs(save_dir, exist_ok=True)
    out_path = os.path.join(save_dir, f"{model}_{impact}{('_' + scope) if scope else ''}.docx")

    # Start from prepend template, or empty doc if not provided
    doc = Document(prepend_docx_path) if prepend_docx_path else Document()

    # Title (+ optional TOC) at the very top (keeps prepend content after TOC if present)
    if toc_dict:
        add_title_and_toc_at_top(
            doc=doc,
            model=model,
            impact=impact,
            scope=scope,
            model_id=model_id,
            model_version=model_version,
            model_name=model_name,
            report_date=report_date,
            toc_dict=toc_dict
        )
    else:
        add_title_only_top(
            doc=doc,
            model=model,
            impact=impact,
            scope=scope,
            model_id=model_id,
            model_version=model_version,
            model_name=model_name,
            report_date=report_date
        )

    # Findings summary table (5 columns, fits page)
    _add_findings_table(doc, findings_df)

    # Section 2: Finding Details (fixed subsections 2.1–2.7)
    _add_section2_finding_details(doc, findings_df)

    # Rows for Q/A, Sections, RFR, etc.
    for i, row in df.iterrows():
        # Question
        pq = doc.add_paragraph()
        _bold_run(pq, f"Question {i+1}: ", size=12)
        _normal_run(pq, str(row[question_col]).strip())
        doc.add_paragraph()

        # Section
        ps = doc.add_paragraph()
        _bold_run(ps, "Section: ")
        _normal_run(ps, str(row[sections_col]).strip())
        doc.add_paragraph()

        # Optional Heading
        if heading_col and heading_col in df.columns:
            ph = doc.add_paragraph()
            _bold_run(ph, "Heading: ")
            _normal_run(ph, str(row.get(heading_col, "")).strip())
            doc.add_paragraph()

        # MRMG Assessment (if present)
        if mrmg_col and mrmg_col in df.columns:
            pm = doc.add_paragraph()
            _bold_run(pm, "MRMG Assessment: ")
            _normal_run(pm, str(row.get(mrmg_col, "")).strip())
            doc.add_paragraph()

        # RFR
        if rfr_col in df.columns:
            _add_heading(doc, "RFR", size=12)
            _add_rfr_block(doc, row.get(rfr_col))

        # Findings (per-question list, if still desired)
        if finding_col and finding_col in df.columns:
            _add_heading(doc, "Findings", size=12)
            lines = _as_finding_lines(row.get(finding_col))
            if lines:
                for line in lines:
                    p = doc.add_paragraph()
                    try:
                        p.style = doc.styles['List Bullet']
                    except Exception:
                        pass
                    _normal_run(p, line)
            else:
                _normal_run(doc.add_paragraph(), "(No findings provided)")

        # Modelling Team Response (space)
        pmt = doc.add_paragraph()
        _bold_run(pmt, "Modelling Team Response", size=11)
        for _ in range(max(0, blank_lines_under_mtr)):
            doc.add_paragraph()
        # spacer
        doc.add_paragraph()

    doc.save(out_path)
    return out_path
