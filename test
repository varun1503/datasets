import os, time, logging
import pandas as pd

# import your classes
# from your_module import ModelDoc, ValReport

def run_pipeline(
    source_docx: str,
    template_docx: str,
    mapping_csv: str,
    out_name: str = "",
    *,
    model_value: str | None = None,     # only used for logging (replaces model.value)
    impact_value: str | None = None,    # only used for logging (replaces impact.value)
    scopes_value: list[str] | None = None,  # replaces scopes.value (pass a list or None)
    logpath: str | None = None,
    print_progress: bool = True
) -> str:
    """
    Run end-to-end (keeps your original logic):
      - source_docx: model document to copy content from
      - template_docx: base validation template
      - mapping_csv: CSV with columns: sections, text, (optional) mrmg_answer/Answer
      - out_name: optional output .docx name
    """

    # --- setup & logging (same spirit as your code) ---
    start_time = time.time()
    user = os.path.expanduser('~').split('/')[-1]
    if logpath is None:
        logpath = os.path.join(os.getcwd(), 'user_logs.log')

    logger = logging.getLogger(__name__)
    # Ensure we have a handler to the desired file
    if not logging.getLogger().handlers:
        logging.basicConfig(filename=logpath, format='%(asctime)s%(message)s', level=logging.INFO)
    else:
        has_same = False
        for h in logging.getLogger().handlers:
            if getattr(h, "baseFilename", None) == os.path.abspath(logpath):
                has_same = True
                break
        if not has_same:
            fh = logging.FileHandler(logpath)
            fh.setFormatter(logging.Formatter('%(asctime)s%(message)s'))
            fh.setLevel(logging.INFO)
            logging.getLogger().addHandler(fh)

    # scope suffix (your original widget logic)
    if scopes_value and len(scopes_value) > 0:
        scope_suffix = '_' + scopes_value[0]
    else:
        scope_suffix = ''

    # paths
    filepath = os.path.abspath(source_docx)
    base_path = os.path.abspath(template_docx)
    mapping_path = os.path.abspath(mapping_csv)

    # output name (your pattern)
    file_name = out_name or (os.path.basename(filepath)[:-5] + ' - Validation Report (Auto).docx')

    # objects
    source = ModelDoc(filepath)
    dest = ValReport(base_path)

    # CSV read: keep exactly your logic (fillna -> dict records)
    mapping = pd.read_csv(mapping_path).fillna('').to_dict(orient='records')

    # processing loop (kept same behavior)
    total = max(len(mapping), 1)
    for i, row in enumerate(mapping, 1):
        if print_progress:
            print(f'Your validation report is getting populated...\nProgress: {round(i/total * 100, 0)}%')

        sections_field = str(row.get('sections', ''))
        # your original used '; ' â€” also tolerate ';' if needed
        parts = sections_field.split('; ') if '; ' in sections_field else sections_field.split(';')

        for s in reversed(parts):
            s = s.strip()
            if not s:
                continue
            if print_progress:
                print(s, row.get('text', ''))
            try:
                section_title, c = source.copy_content(start=s)
                dest.paste_content(c, row.get('text', ''), str(i))
                dest.put_text(row.get('text', ''), 'Model Document Section: ' + section_title, 'magenta')
                dest.put_text(row.get('text', ''), ' ', '')
                break  # success for this row
            except Exception:
                try:
                    dest.put_text(row.get('text', ''), 'ERROR: Model Document Section ' + s, 'red')
                    if print_progress:
                        print('ERROR: ', (s, row.get('text', '')))
                except Exception:
                    if print_progress:
                        print('ERROR: The following mapping is incorrect:\n', (s, row.get('text', '')))
                # continue trying remaining candidates

    # save
    final_path = dest.save(file_name)

    end_time = time.time()
    # Logging - userID : filename : Button configs : runtime
    logger.info(f";{user};{os.path.basename(filepath)[:-5]};{(model_value, impact_value, scopes_value)};{end_time - start_time:.2f}")

    if print_progress:
        print('Completed! Please download the report now')

    return os.path.abspath(final_path)

if __name__ == "__main__":
    out = run_pipeline(
        source_docx=r"data_type\5211_IVR_Intent_Recognition_US_Market_v1.1_Documentation.docx",
        template_docx=r"base\test_C.docx",               # <-- pass your real template path
        mapping_csv=r"data_type\Technology_C.csv",
        out_name="",                                      # leave "" to auto-name from source
        model_value="test",                               # only for logging line
        impact_value="C",                                 # only for logging line
        scopes_value=["Retail"],                          # or []/None
        logpath=r"c:\Users\vvaishy\Documents\hpt_rasa\mrmg_preprocess\600004454-validationreport\user_logs.log",
        print_progress=True
    )
    print("Saved to:", out)
