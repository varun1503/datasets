import os
import json
import ast
from typing import Optional, Any, Iterable, Dict, List, Sequence
import pandas as pd
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml import OxmlElement
from docx.oxml.ns import qn

# ---------- styling config for permanent tables ----------
HEADER_BG_HEX    = "D9E1F2"   # header fill
BORDER_COLOR_HEX = "C5D9F1"   # borders
BORDER_SZ        = 6          # ~0.5pt

PERMANENT_TABLES = {
    "Overview": {
        "columns":   ["Item", "Description", "Owner", "Status"],
        "widths_in": [1.2,    3.5,           1.3,     1.0],
        "rows": 3,
        "align": ["LEFT","LEFT","LEFT","CENTER"]
    },
    "Scope": {
        "columns":   ["In Scope", "Out of Scope", "Assumptions", "Dependencies"],
        "widths_in": [2.2,       2.2,           1.8,           1.8],
        "rows": 3
    },
    "Timeline": {
        "columns":   ["Milestone", "Start Date", "End Date", "Owner", "Notes"],
        "widths_in": [2.2,        1.2,          1.2,        1.2,    2.0],
        "rows": 4,
        "align": ["LEFT","CENTER","CENTER","LEFT","LEFT"]
    },
    "Results": {
        "columns":   ["Metric", "Baseline", "Target", "Actual", "Status"],
        "widths_in": [2.2,     1.2,       1.2,     1.2,     1.5],
        "rows": 4,
        "align": ["LEFT","CENTER","CENTER","CENTER","CENTER"]
    },
}

# ---------- helpers (your originals kept) ----------
def _bold_run(p, text, size=11):
    r = p.add_run(text)
    r.bold = True
    r.font.size = Pt(size)
    return r

def _normal_run(p, text, size=11):
    r = p.add_run(text)
    r.font.size = Pt(size)
    return r

def safe_json_loads(cell: Any):
    """Pass-through for dict/list; try json/literal for strings."""
    if isinstance(cell, (dict, list)) or cell is None:
        return cell
    if not isinstance(cell, str):
        return cell
    try:
        return json.loads(cell)
    except Exception:
        pass
    try:
        return ast.literal_eval(cell)
    except Exception:
        return cell

def _add_heading(doc: Document, text: str, size=12):
    p = doc.add_paragraph()
    _bold_run(p, text, size=size)

# ---------- NEW: table helpers for permanent sections ----------
def _twips(inches: float) -> int:
    return int(inches * 1440)

def _set_tbl_borders(tbl, color_hex=BORDER_COLOR_HEX, sz=BORDER_SZ):
    tbl_pr = tbl._tbl.tblPr
    tbl_borders = tbl_pr.tblBorders
    if tbl_borders is None:
        tbl_borders = OxmlElement('w:tblBorders')
        tbl_pr.append(tbl_borders)

    def _border(tag: str):
        el = tbl_borders.find(qn(f'w:{tag}'))
        if el is None:
            el = OxmlElement(f'w:{tag}')
            tbl_borders.append(el)
        el.set(qn('w:val'), 'single')
        el.set(qn('w:sz'), str(sz))
        el.set(qn('w:color'), color_hex)
        el.set(qn('w:space'), '0')

    for side in ('top','left','bottom','right','insideH','insideV'):
        _border(side)

def _set_cell_shading(cell, fill_hex: str):
    tc_pr = cell._tc.get_or_add_tcPr()
    shd = tc_pr.find(qn('w:shd'))
    if shd is None:
        shd = OxmlElement('w:shd')
        tc_pr.append(shd)
    shd.set(qn('w:fill'), fill_hex)
    shd.set(qn('w:val'), 'clear')
    shd.set(qn('w:color'), 'auto')

def _set_col_widths(tbl, widths_in: List[float]):
    if not widths_in:
        return
    for j, w in enumerate(widths_in):
        for row in tbl.rows:
            cell = row.cells[j]
            tc_pr = cell._tc.get_or_add_tcPr()
            tc_w = tc_pr.find(qn('w:tcW'))
            if tc_w is None:
                tc_w = OxmlElement('w:tcW')
                tc_pr.append(tc_w)
            tc_w.set(qn('w:w'), str(_twips(w)))
            tc_w.set(qn('w:type'), 'dxa')

def _align_map(val: str):
    v = (val or "").upper()
    return {
        "LEFT": WD_ALIGN_PARAGRAPH.LEFT,
        "CENTER": WD_ALIGN_PARAGRAPH.CENTER,
        "RIGHT": WD_ALIGN_PARAGRAPH.RIGHT
    }.get(v, WD_ALIGN_PARAGRAPH.LEFT)

def _create_permanent_empty_table(doc: Document, title: str, cfg: Dict):
    # section label
    p = doc.add_paragraph()
    _bold_run(p, title, size=12)

    cols = cfg["columns"]
    rows = cfg.get("rows", 3)
    widths = cfg.get("widths_in")
    align = cfg.get("align")

    # table with 1 header row + empty rows
    tbl = doc.add_table(rows=1 + rows, cols=len(cols))
    _set_tbl_borders(tbl)
    _set_col_widths(tbl, widths)

    # header row
    hdr = tbl.rows[0]
    for i, col in enumerate(cols):
        para = hdr.cells[i].paragraphs[0]
        para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        _bold_run(para, str(col))
        _set_cell_shading(hdr.cells[i], HEADER_BG_HEX)

    # body rows (empty cells, alignment per column if provided)
    for r in range(1, 1 + rows):
        for c in range(len(cols)):
            para = tbl.rows[r].cells[c].paragraphs[0]
            para.alignment = _align_map(align[c]) if align and c < len(align) else WD_ALIGN_PARAGRAPH.LEFT

    # spacer
    doc.add_paragraph()

# ---------- your RFR/Findings helpers ----------
def _add_rfr_block(doc: Document, rfr_obj: Any):
    """
    Render an RFR section from a dict like {"Q1": "answer ...", "Q2": "..."}.
    Also tolerates JSON-ish strings by parsing first.
    """
    rfr_obj = safe_json_loads(rfr_obj)
    if not rfr_obj:
        _normal_run(doc.add_paragraph(), "(No RFR provided)")
        return

    if isinstance(rfr_obj, dict):
        for k, v in rfr_obj.items():
            # Question key (bold)
            p_q = doc.add_paragraph()
            _bold_run(p_q, f"{str(k).strip()}: ", size=11)

            # Response/value
            p_a = doc.add_paragraph()
            _bold_run(p_a, "Response: ", size=11)
            _normal_run(p_a, str(v).strip())
    else:
        # Fallback dump
        _normal_run(doc.add_paragraph(), str(rfr_obj).strip())

def _as_finding_lines(x: Any):
    """
    Normalize findings to list[str]. Accepts list/ dict / string / JSON-ish.
    """
    x = safe_json_loads(x)
    if x is None:
        return []
    if isinstance(x, list):
        return [str(it).strip() for it in x if str(it).strip()]
    if isinstance(x, dict):
        return [f"{k}: {v}" for k, v in x.items() if str(v).strip()]
    if isinstance(x, str):
        s = x.strip()
        return [s] if s else []
    return [str(x).strip()]

# ---------- main ----------
def build_simple_template(
    df: pd.DataFrame,
    model: str,
    impact: str,
    scope: str = "",
    save_dir: str = "base",
    *,
    question_col: str = "text",
    sections_col: str = "sections",
    mrmg_col: Optional[str] = "mrmg_answer",
    heading_col: Optional[str] = None,  # if you have one
    rfr_col: str = "RFR",               # your dict column (already set)
    finding_col: Optional[str] = "Findings",
    blank_lines_under_mtr: int = 2,
    include_permanent_tables: bool = True  # <--- NEW flag
) -> str:
    # sanity
    for col in [question_col, sections_col]:
        if col not in df.columns:
            raise KeyError(f"Missing required column: {col}")

    os.makedirs(save_dir, exist_ok=True)
    out_path = os.path.join(save_dir, f"{model}_{impact}{('_' + scope) if scope else ''}.docx")

    doc = Document()

    # Title
    t = doc.add_paragraph()
    r = t.add_run("Validation Report (Template)")
    r.bold = True
    r.font.size = Pt(16)
    t.alignment = WD_ALIGN_PARAGRAPH.CENTER
    doc.add_paragraph()

    # Meta
    doc.add_paragraph(f"Model: {model} | Impact: {impact}{(' | Scope: ' + scope) if scope else ''}")
    doc.add_paragraph()

    # --- NEW: permanent, empty, styled tables at the very top ---
    if include_permanent_tables:
        for section_name, cfg in PERMANENT_TABLES.items():
            _create_permanent_empty_table(doc, section_name, cfg)

    # --- Your existing df-driven sections below ---
    for i, row in df.iterrows():
        # Question
        pq = doc.add_paragraph()
        _bold_run(pq, f"Question {i+1}: ", size=12)
        _normal_run(pq, str(row[question_col]).strip())

        # Section
        ps = doc.add_paragraph()
        _bold_run(ps, "Section: ")
        _normal_run(ps, str(row[sections_col]).strip())

        # Optional Heading
        if heading_col and heading_col in df.columns:
            ph = doc.add_paragraph()
            _bold_run(ph, "Heading: ")
            _normal_run(ph, str(row.get(heading_col, "")).strip())

        # MRMG Assessment (if present)
        if mrmg_col and mrmg_col in df.columns:
            pm = doc.add_paragraph()
            _bold_run(pm, "MRMG Assessment: ")
            _normal_run(pm, str(row.get(mrmg_col, "")).strip())

        # RFR
        if rfr_col in df.columns:
            _add_heading(doc, "RFR", size=12)
            _add_rfr_block(doc, row.get(rfr_col))

        # Findings
        if finding_col and finding_col in df.columns:
            _add_heading(doc, "Findings", size=12)
            lines = _as_finding_lines(row.get(finding_col))
            if lines:
                for line in lines:
                    p = doc.add_paragraph(style=None)
                    try:
                        p.style = doc.styles['List Bullet']  # bullet style if available
                    except Exception:
                        pass
                    _normal_run(p, line)
            else:
                _normal_run(doc.add_paragraph(), "(No findings provided)")

        # Modelling Team Response (space)
        pmt = doc.add_paragraph()
        _bold_run(pmt, "Modelling Team Response", size=11)
        for _ in range(max(0, blank_lines_under_mtr)):
            doc.add_paragraph()

        # spacer
        doc.add_paragraph()

    doc.save(out_path)
    return out_path
