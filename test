I understand! You want to capture content within `<>` brackets (like `<Q4: MRMG Test 1>`, `<Data Validation>`, etc.) from the document. Here's the updated code with that functionality added:

```python
import re
import json
import unicodedata
import os
import pandas as pd
from typing import List, Dict, Tuple, Optional
from docx import Document
from collections import OrderedDict
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.table import _Cell, Table
from docx.text.paragraph import Paragraph

def group_blocks_from_list(
    lines: List[str],
    start_rx: re.Pattern,
    stop_rx: Optional[re.Pattern] = None,
    stop_substrings: Optional[List[str]] = None,
    joiner: str = "",
    include_stop_line: bool = False,
) -> List[Tuple[int, int, str]]:
    """
    Group consecutive lines from a list into blocks.
    Returns a list of tuples (start_idx, end_idx, grouped_text).
    """
    stop_substrings = stop_substrings or []
    grouped_blocks = []
    buf = []
    capturing = False
    start_idx = 0

    def flush(end_idx):
        nonlocal buf
        if buf:
            grouped_text = joiner.join(s.strip() for s in buf if s.strip())
            grouped_blocks.append((start_idx, end_idx, grouped_text))
            buf = []

    for i, line in enumerate(lines):
        s = (line or "").strip()
        
        if start_rx.search(s):
            if capturing:
                flush(i - 1)
            capturing = True
            start_idx = i
            buf = [line]
            continue
        
        if capturing:
            if stop_rx and stop_rx.search(s):
                if include_stop_line:
                    buf.append(line)
                flush(i if include_stop_line else i - 1)
                capturing = False
            elif any(sub in s for sub in stop_substrings):
                flush(i - 1)
                capturing = False
            else:
                buf.append(line)
    
    if capturing:
        flush(len(lines) - 1)
    
    return grouped_blocks


def replace_blocks_in_lines(lines: List[str], grouped_blocks: List[Tuple[int, int, str]]) -> List[str]:
    """
    Replace original RFR block lines with their grouped version, preserving sequence.
    """
    replaced = []
    i = 0
    block_map = {start: (end, text) for start, end, text in grouped_blocks}
    
    while i < len(lines):
        if i in block_map:
            end_idx, text = block_map[i]
            replaced.append(text)
            i = end_idx + 1
        else:
            replaced.append(lines[i])
            i += 1
    
    return replaced


# Example usage
RFR_RX = re.compile(r"\s*RFR\s*\d+\s*", re.IGNORECASE)
STOP_SUBS = ["[Modeling Team's Response]", "[", "Modeling Team's Response"]


# helpers
def norm(s: str) -> str:
    if not s:
        return ""
    s = unicodedata.normalize("NFKC", s).replace("\u00A0", "")
    return re.sub(r"\s+", " ", s).strip()


def get_paragraph_indent(paragraph: Paragraph) -> int:
    """
    Get the indentation of a paragraph in spaces.
    Converts left_indent to approximate number of spaces.
    """
    indent = paragraph.paragraph_format.left_indent
    if indent and indent > 0:
        try:
            indent_inches = indent.inches
            # Convert to spaces (8 spaces per inch, adjust as needed)
            return int(indent_inches * 8)
        except:
            # Fallback: convert EMUs to inches
            indent_value = indent / 914400
            return int(indent_value * 8)
    return 0


def extract_angle_bracket_content(text: str) -> List[str]:
    """
    Extract all content within <> brackets from text.
    Returns a list of extracted content.
    
    Examples:
        "<Q4: MRMG Test 1>" -> ["Q4: MRMG Test 1"]
        "<Data Validation> | <For manually labeled data>" -> ["Data Validation", "For manually labeled data"]
    """
    # Pattern to match content within < >
    pattern = r'<([^>]+)>'
    matches = re.findall(pattern, text)
    return [match.strip() for match in matches]


def preserve_indent_and_extract_brackets(text: str, indent_spaces: int) -> Tuple[str, List[str]]:
    """
    Given a text line with indentation, preserve the indent and extract bracket content.
    
    Returns:
        Tuple of (indented_text, list_of_bracket_contents)
    """
    indented_text = " " * indent_spaces + text
    bracket_contents = extract_angle_bracket_content(text)
    return indented_text, bracket_contents


def read_docx_lines(path: str, extract_brackets: bool = True) -> Tuple[List[str], Dict[int, List[str]]]:
    """
    Read docx and preserve indentation as leading spaces in the text.
    
    Args:
        path: Path to the docx file
        extract_brackets: If True, also extract content within <> brackets
    
    Returns:
        Tuple of (lines_with_indentation, dict mapping line_index to bracket_contents)
    """
    doc = Document(path)
    lines: List[str] = []
    bracket_map: Dict[int, List[str]] = {}
    line_idx = 0
    
    # Walk through document body in order
    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):  # Paragraph
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                # Get indentation and add as leading spaces
                num_spaces = get_paragraph_indent(p)
                indented_text = " " * num_spaces + t
                lines.append(indented_text)
                
                # Extract bracket content if requested
                if extract_brackets:
                    bracket_contents = extract_angle_bracket_content(t)
                    if bracket_contents:
                        bracket_map[line_idx] = bracket_contents
                
                line_idx += 1
        
        elif child.tag == qn("w:tbl"):  # Table
            tbl = Table(child, doc)
            for row in tbl.rows:
                row_text = []
                row_brackets = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            # Get indentation for table cell paragraphs too
                            num_spaces = get_paragraph_indent(p)
                            indented_text = " " * num_spaces + t
                            row_text.append(indented_text)
                            
                            # Extract bracket content
                            if extract_brackets:
                                bracket_contents = extract_angle_bracket_content(t)
                                if bracket_contents:
                                    row_brackets.extend(bracket_contents)
                
                if row_text:
                    combined_row = " | ".join(row_text)
                    lines.append(combined_row)
                    
                    if row_brackets:
                        bracket_map[line_idx] = row_brackets
                    
                    line_idx += 1
    
    # Group blocks (this preserves the indentation in the grouped text)
    blocks = group_blocks_from_list(lines, start_rx=RFR_RX, stop_substrings=STOP_SUBS)
    final_lines = replace_blocks_in_lines(lines, blocks)
    
    return final_lines, bracket_map


# Example usage:
if __name__ == "__main__":
    # Read lines with indentation and extract bracket content
    lines, bracket_content = read_docx_lines("your_document.docx", extract_brackets=True)
    
    # Print lines with preserved indentation
    for i, line in enumerate(lines):
        print(line)
        
        # If this line has bracket content, print it
        if i in bracket_content:
            print(f"  -> Bracket content: {bracket_content[i]}")
    
    # Or just print lines
    print("\n--- Just Lines ---")
    for line in lines:
        print(line)
    
    # Or access bracket content separately
    print("\n--- Bracket Contents ---")
    for line_idx, contents in bracket_content.items():
        print(f"Line {line_idx}: {contents}")
```

## Output Example:

```
4. [RFR1]: <Q4: MRMG Test 1>
  -> Bracket content: ['Q4: MRMG Test 1']
    a. Subtest a
        i. Sub2test >| <Data Validation> | <For manually labeled data, is observer bias appropriately controlled...>
  -> Bracket content: ['Data Validation', 'For manually labeled data, is observer bias appropriately controlled...']
```

## Key Features Added:

1. **`extract_angle_bracket_content()`**: Extracts all content within `<>` brackets using regex
2. **`preserve_indent_and_extract_brackets()`**: Helper to do both operations
3. **Modified `read_docx_lines()`**: 
   - Now returns a tuple: `(lines, bracket_map)`
   - `bracket_map` is a dictionary mapping line index to list of bracket contents
   - Extracts brackets from both regular paragraphs and table cells

You can use it in two ways:
- Get both lines and bracket content separately
- Just get the lines if you set `extract_brackets=False`        try:
            indent_inches = indent.inches
            # Convert to spaces (8 spaces per inch, adjust as needed)
            return int(indent_inches * 8)
        except:
            # Fallback: convert EMUs to inches
            indent_value = indent / 914400
            return int(indent_value * 8)
    return 0


def read_docx_lines(path: str) -> List[str]:
    """
    Read docx and preserve indentation as leading spaces in the text.
    """
    doc = Document(path)
    lines: List[str] = []
    
    # Walk through document body in order
    for child in doc.element.body.iterchildren():
        if child.tag == qn("w:p"):  # Paragraph
            p = Paragraph(child, doc)
            t = norm(p.text)
            if t:
                # Get indentation and add as leading spaces
                num_spaces = get_paragraph_indent(p)
                indented_text = " " * num_spaces + t
                lines.append(indented_text)
        
        elif child.tag == qn("w:tbl"):  # Table
            tbl = Table(child, doc)
            for row in tbl.rows:
                row_text = []
                for cell in row.cells:
                    for p in cell.paragraphs:
                        t = norm(p.text)
                        if t:
                            # Get indentation for table cell paragraphs too
                            num_spaces = get_paragraph_indent(p)
                            indented_text = " " * num_spaces + t
                            row_text.append(indented_text)
                if row_text:
                    lines.append(" | ".join(row_text))
    
    # Group blocks (this preserves the indentation in the grouped text)
    blocks = group_blocks_from_list(lines, start_rx=RFR_RX, stop_substrings=STOP_SUBS)
    final_lines = replace_blocks_in_lines(lines, blocks)
    
    return final_lines


# Example usage:
if __name__ == "__main__":
    lines = read_docx_lines("your_document.docx")
    for line in lines:
        print(line)  # This will print with preserved indentation
```

## Key Changes:

1. **Added `get_paragraph_indent()` function**: Extracts indentation from paragraphs and converts it to spaces

2. **Modified `read_docx_lines()` function**:
   - Gets indentation for each paragraph using `get_paragraph_indent(p)`
   - Adds leading spaces to the text: `" " * num_spaces + t`
   - Also handles indentation for table cell paragraphs

3. **Preserved all existing logic**: The `norm()`, grouping, and replacement logic remains unchanged

Now when you print the lines, they will have the same indentation as in the Word document!
